import sys, os, json
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5 import QtMultimedia


class AudioPlayer(QWidget):
    def __init__(self, audio:str, file_, parent = None):
        QWidget.__init__(self, parent, flags =
                                   Qt.Window | Qt.MSWindowsFixedSizeDialogHint)
        # создание плеера
        self.audioPlayer = QtMultimedia.QMediaPlayer()
        self.audioPlayer.setVolume(100)
        self.audioPlayer.mediaStatusChanged.connect(self.initPlayer)
        self.audioPlayer.stateChanged.connect(self.setPlayerState)
        vbox = QHBoxLayout()
        # кнопка Play
        self.btnPlay = QPushButton('Play')
        self.btnPlay.clicked.connect(self.audioPlayer.play)
        self.btnPlay.setEnabled(False)
        vbox.addWidget(self.btnPlay)
        # Timeline
        self.sldPosition = QSlider(Qt.Horizontal)
        self.sldPosition.setMinimum(0)
        self.sldPosition.valueChanged.connect(self.audioPlayer.setPosition)
        self.audioPlayer.positionChanged.connect(self.sldPosition.setValue)
        self.audioPlayer.setMedia(QtMultimedia.QMediaContent(file_))
        self.sldPosition.setEnabled(False)
        vbox.addWidget(self.sldPosition)

        self.setLayout(vbox)
        self.resize(300, 50)

    def openFile(self): # ОТКРЫЕТИЕ ФАЙЛА
         file = QFileDialog.getOpenFileUrl(parent=self,
                                                     caption="Выберите файл")
         self.audioPlayer.setMedia(QtMultimedia.QMediaContent(file[0]))

    def initPlayer(self, state): # КОНСТРУКТОР ПЛЕЕРА
        if state == QtMultimedia.QMediaPlayer.LoadedMedia: # состояние плеера при загрузке аудио

            self.audioPlayer.stop()
            self.btnPlay.setEnabled(True)
            #self.sldPosition.setEnabled(True)
            self.sldPosition.setMaximum(self.audioPlayer.duration())

        elif state == QtMultimedia.QMediaPlayer.EndOfMedia: # при конце аудио
            self.audioPlayer.stop()

        elif state == QtMultimedia.QMediaPlayer.NoMedia or state == QtMultimedia.QMediaPlayer.InvalidMedia:
            # при отсуствии аудио
            self.sldPosition.setValue(0)
            self.sldPosition.setEnabled(False)
            self.btnPlay.setEnabled(False)

    def setPlayerState(self, state): # ДЕЙСТВИЯ ПРИ НАЖАТИИ PLAY
        if state == QtMultimedia.QMediaPlayer.PlayingState:
            # при включенном аудио
            self.btnPlay.setEnabled(True)
            self.btnPlay.setText('Pause')
            self.btnPlay.clicked.connect(self.audioPlayer.pause)

        elif state == QtMultimedia.QMediaPlayer.PausedState:
            # при выключенном
            self.btnPlay.setEnabled(True)
            self.btnPlay.setText('Play')
            self.btnPlay.clicked.connect(self.audioPlayer.play)


class MyPushButton(QPushButton):
    """
    Переписанный класс QPushButton
    Создан для того, чтобы можно было разделять левый и правый щелчок мыши на два сигнала
    """
    rightClick = pyqtSignal()
    leftClick = pyqtSignal()

    def __init__(self, string):
        super(QPushButton, self).__init__(string)

    def mousePressEvent(self, event):
        if event.button() == Qt.RightButton:
            self.rightClick.emit()
        elif event.button() == Qt.LeftButton:
            self.leftClick.emit()

        QPushButton.mousePressEvent(self, event)


"""
В двух фукнциях ты найдешь наш новый дизайн подзаметок,
Там нужно вставить пару вещей и уточнить 
Теперь все контекстное меню будет в toolButton, как и открытие подзаметки (то есть полное открытие)
Хэштег, пока что, можно добавлять только через нее же (и то нельзя, ибо мои поправки для хэштегов не сработали,
приспособь под свою систему

Самый главный вопрос, так это стоит ли (и как именно?) помещать создание дизайна в отдельную функцию
для лучшей читаемости кода?
"""

class Notes(QWidget):
    def __init__(self):
        super(Notes, self).__init__()

        self.path = os.getcwd() #определяет директорию с .py файлом

        if not os.path.exists(self.path + r"\MainNote.json"):
            self.create_main_file()

        json_data = json.load(open(self.path + r'\MainNote.json', 'r+'))  # считываем данные с json файла
        jtopy = json.dumps(json_data)
        self.main_dict = json.loads(jtopy)  # КЛАДЕМ ДАННЫЕ В СЛОВАРЬ ГЛАВНОЙ ЗАМЕТКИ

        self.notes_dict_list = []  # СПИСОК С ЗАМЕТКАМИ
        i = 1
        while os.path.exists(self.path + r"\Note" + str(i) + ".json"):
            json_data = json.load(open(self.path + r"\Note" + str(i) + ".json", 'r+'))
            jtopy = json.dumps(json_data)
            note_dict = json.loads(jtopy)
            self.notes_dict_list.append(note_dict)
            i += 1

        self.notes_count = len(self.notes_dict_list)  # КОЛИЧЕСТВО ЗАМЕТОК

        self.initUI()

    def initUI(self):

        # Размеры
        self.setWindowTitle('Note')
        self.setGeometry(300, 200, 650, 450)

        # Нулевой слой
        self.ZLay = QVBoxLayout()
        self.setLayout(self.ZLay)

        # Первый слой
        self.mainLayout = QHBoxLayout()
        self.ZLay.addLayout(self.mainLayout)

        # Основная сетка
        self.middleFrame = QFrame()
        self.middleLayout = QVBoxLayout()
        self.middleFrame.setLayout(self.middleLayout)
        self.mainLayout.addWidget(self.middleFrame)

        self.textFrame = QFrame()
        self.widgetFrame = QFrame()
        self.textFrame.setStyleSheet('border-radius:10px;')

        self.middleLayout.addWidget(self.textFrame)
        self.mainLayout.addWidget(self.widgetFrame)

        self.textLayout = QVBoxLayout()
        self.textFrame.setLayout(self.textLayout)

        self.widgetLay = QVBoxLayout()

        # lay and frame for images
        self.imgLayout = QHBoxLayout()
        self.imgFrame = QFrame()
        self.imgFrame.setLayout(self.imgLayout)
        self.widgetLay.addWidget(self.imgFrame)

        # lay and frame for notes
        self.noteLayout = QVBoxLayout()
        self.noteFrame = QFrame()
        self.noteFrame.setLayout(self.noteLayout)
        self.widgetLay.addWidget(self.noteFrame)

        # lay and frame for audio
        self.audioLayout = QHBoxLayout()
        self.audioFrame = QFrame()
        self.audioFrame.setLayout(self.audioLayout)
        self.widgetLay.addWidget(self.audioFrame)

        self.widgetFrame.setLayout(self.widgetLay)

        self.note_name_lbl = QLabel("MainNote")
        self.textLayout.addWidget(self.note_name_lbl)

        self.date_lbl = QLabel("Last Edit: " + self.main_dict["date"])
        self.textLayout.addWidget(self.date_lbl)

        self.textedit = QTextEdit()
        self.textedit.setFrameStyle(14)
        self.textLayout.addWidget(self.textedit)
        self.textedit.setStyleSheet("font:12pt 'sans-serif';\n"
"background-color: rgb(230,216,203);\n"
"color: black;")




        # -----------------
        # Кнопки

        self.buttonLayout = QHBoxLayout()

        # Menu
        self.menuButton = MyPushButton("Menu")
        self.buttonLayout.addWidget(self.menuButton)
        self.menuButton.leftClick.connect(self.show_left_menu)

        # Левое меню
        self.frame_menu = QFrame()
        self.frame_menu.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)
        self.left_menu = QVBoxLayout()
        self.frame_menu.move(self.menuButton.x(),self.menuButton.y())
        self.tree = QTreeWidget()
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.tree_context_menu)
        self.left_menu.addWidget(self.tree)
        self.left_menu.addStretch()
        self.frame_menu.setLayout(self.left_menu)
        #self.mainLayout.addWidget(self.frame_menu)

        # Активная на данный момент заметка
        self.open_note_sys_name = 'MainNote'
        self.open_note_index = -1

        # Словарь для хранения заметок по хэштегам
        self.hash_dict = {}
        for i in self.notes_dict_list:
                self.hash_dict.update({i["hashtag"]:[]})
        for i in self.notes_dict_list:
            for key in self.hash_dict:
                if i["hashtag"] == key:
                    self.hash_dict[key].append({"user_name": i["user_name"], "note_item": ""})

        # Создание древовидного виджета для заметок по категориям
        self.cycle_for_items()

        # Начальный документ
        doc = QTextDocument()
        doc.setPlainText(self.open_text(-1))
        doc.contentsChanged.connect(lambda: self.save_main_note_text())
        doc.setDefaultStyleSheet("border-style: outset;\n"
"background-color: rgb(240,240,240);\n"
"border-radius:10px;\n")
        self.textedit.setDocument(doc)
        self.textedit.setFocus()  # устанавливает курсор в текстовое поле

        # Arrow
        self.homeButton = MyPushButton('Main Note')
        self.buttonLayout.addWidget(self.homeButton)
        self.homeButton.leftClick.connect(lambda: self.show_main_note_text())
        self.homeButton.leftClick.connect(lambda: self.change_open_note('MainNote', -1))

        # Plus
        self.plusButton = MyPushButton('Plus')
        self.buttonLayout.addWidget(self.plusButton)
        self.plusButton.leftClick.connect(lambda: self.new_note())
        self.plusButton.setShortcut("Ctrl+N")


        # Меню для кнопки-скрепки
        contextMenuForButton = QMenu()

        addImage = QAction('Image', self)
        addImage.triggered.connect(lambda: self.add_img())
        addTable = QAction('Table', self)
        addTable.triggered.connect(lambda: self.add_table())
        addAudio = QAction('Audio', self)
        addAudio.triggered.connect(lambda: self.add_audio())

        contextMenuForButton.addAction(addImage)
        contextMenuForButton.addAction(addTable)
        contextMenuForButton.addAction(addAudio)
        contextMenuForButton.addSeparator()

        contextMenuForButton.customContextMenuRequested.connect(lambda: self.show_context_menu())

        # Screpka
        self.clipButton = MyPushButton('Screpka')
        self.clipButton.setMenu(contextMenuForButton)
        self.buttonLayout.addWidget(self.clipButton)

        self.ZLay.addLayout(self.buttonLayout)
        #self.scrollAr.addScrollBarWidget(self.ZLay)

        # Запускаем цикл
        self.change_open_note('MainNote', -1)
        self.cycle_all_notes()

    #-------------------------Functions for MainNote-------------------------
    def create_main_file(self):  # СОЗДАНИЕ ГЛАВНОЙ ЗАМЕТКИ
        text = '{{"text": "", "date": "{}"}}'.format(self.note_date_func())
        with open(self.path + r'\MainNote.json', 'w+') as f:
            f.write(text)

    @pyqtSlot()
    def show_main_note_text(self):  # ОТОБРАЖАЕТ ГЛАВНУЮ ЗАМЕТКУ
        main_txtEdit = QTextDocument()
        main_txtEdit.setPlainText(self.open_text(-1))
        main_txtEdit.setDefaultStyleSheet("border-style: outset;\n"
"background-color: rgb(240,240,240);\n"
"border-radius:10px;\n")
        self.textedit.setDocument(main_txtEdit)
        self.textedit.setFocus() # устанавливает курсор в текстовое поле
        self.note_name_lbl.setText("MainNote")
        self.date_lbl.setText("Last Edit: " + self.main_dict["date"])
        main_txtEdit.contentsChanged.connect(lambda: self.save_main_note_text())



    #-------------------------Functions for launching notes-------------------------
    @pyqtSlot()
    def cycle_all_notes(self):  # ПРОХОДИТСЯ ЦИКЛОМ ПО ВСЕМ ЗАМЕТКАМ
        for note in self.notes_dict_list:
            self.show_note_box(note["sys_name"], note["index"], note["user_name"], note["hashtag"])

    @pyqtSlot(str)
    def show_note_box(self, sys_name, index, user_name, hashtag):  # ОТОБРАЖАЕТ И АКТИВИРУЕТ КНОПКУ
        print(self.notes_dict_list)

        memoLayout = QVBoxLayout()

        mainGroupBox = QGroupBox()
        mainGroupBox.setGeometry(QRect(300, 160, 261, 251))
        mainGroupBox.setMaximumSize(QSize(300, 300))
        mainGroupBox.setStyleSheet("border-radius: 10px;\n"
"background-color: rgb(83,90,87);")

        mainVerticalLayout = QVBoxLayout(mainGroupBox)
        mainVerticalLayout.setContentsMargins(0, 0, 0, 0)

        topGroupBox = QGroupBox(mainGroupBox)
        topGroupBox.setStyleSheet("background-color: rgb(0, 0, 0);\n"
"font: 87 9pt \"Arial Black\";\n"
"color: white;")

        topHorizontalLayout = QHBoxLayout(topGroupBox)

        textGroupBox = QGroupBox(mainGroupBox)
        verticalLayout = QVBoxLayout(textGroupBox)

        mainVerticalLayout.addWidget(topGroupBox)
        mainVerticalLayout.addWidget(textGroupBox)

        memoLayout.addLayout(mainVerticalLayout)
        memoLayout.addWidget(mainGroupBox)


        verticalLayout.setContentsMargins(9, 0, 9, 9)

        self.noteLayout.addLayout(memoLayout)
        # self.noteLayout.addWidget(mainGroupBox)
        # self.noteLayout.addLayout(verticalLayout)

        nameLabel = QLabel(topGroupBox) # name
        nameLabel.setText(user_name)
        topHorizontalLayout.addWidget(nameLabel)
        hashtagLabel = QLabel(topGroupBox) #hashtag
        hashtagLabel.setText(hashtag)
        topHorizontalLayout.addWidget(hashtagLabel)

        toolButton = QToolButton(topGroupBox)
        toolButton.setCursor(QCursor(Qt.PointingHandCursor))
        toolButton.setCheckable(False)
        toolButton.setAutoRepeat(False)
        toolButton.setAutoExclusive(False)
        toolButton.setAutoRaise(False)
        toolButton.setText( "...")

        toolMenu = QMenu()

        removeAction = QAction('Remove')
        removeAction.triggered.connect(lambda: self.note_del(index=index, note_layout=memoLayout, note_hashtag=hashtag,
                                                              sys_name=sys_name, user_name=user_name))
        toolMenu.addAction(removeAction)

        renameAction = QAction('Rename')
        renameAction.triggered.connect(lambda: self.rename_note(sys_name, hashtag, index, user_name))
        toolMenu.addAction(renameAction)

        openAction = QAction()
        openAction.triggered.connect(lambda: self.show_note_box(sys_name=sys_name, index=index))
        toolMenu.addAction(openAction)
        toolButton.setMenu(toolMenu)

        topHorizontalLayout.addWidget(toolButton)

        textEdit = QTextEdit(textGroupBox)
        textEdit.setMinimumSize(QSize(200, 150))
        textEdit.setMaximumSize(QSize(300, 400))
#         textEdit.setStyleSheet("border-style: outset;\n"
# "background-color: rgb(240,240,240);")
        textEdit.setStyleSheet("font:12pt 'sans-serif';\n"
"background-color: rgb(230,216,203);\n"
"color: black;")
        textEdit.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:7.8pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Note\'s name...</p></body></html>")
        verticalLayout.addWidget(textEdit)


        self.notes_dict_list[index]["note_layout"] = memoLayout # что именно сюда нужно помещать?
                                                        # ты помещал свою кнопку, теперь у нас много объектов и помещать нужно кортеж
                                                        # Предлагаю такое:
                                                        # mainGroupBox, verticalLayout, - последняя запятая нужна для выебонов



        # note_layout.leftClick.connect(lambda: self.show_note_text(sys_name, index))
        # note_layout.rightClick.connect(lambda: self.context_menu(note_layout, hashtag, index, sys_name, user_name))
        # note_layout.leftClick.connect(lambda: self.change_open_note(sys_name, index))
        # note_layout.leftClick.connect(lambda: self.note_name_lbl_func(user_name))
        # note_layout.destroyed.connect(lambda: self.del_print(user_name))


        print(self.notes_dict_list)

    @pyqtSlot(str)
    def show_note_text(self):  # СОЗДАЕТ ТЕСТОВОЕ ПОЛЕ QTEXTDOCUMENT И АКТИВИРУЕТ СОХРАНЕНИЕ
        note_doc = QTextDocument()
        note_doc.setPlainText(self.open_text(self.open_note_index))
        self.textedit.setDocument(note_doc)
        self.textedit.setFocus() # устанавливает курсор в текстовое поле
        self.date_lbl.setText("Last Edit: " + self.notes_dict_list[self.open_note_index]["date"])
        self.note_name_lbl.setText(self.notes_dict_list[self.open_note_index]["user_name"])
        note_doc.contentsChanged.connect(lambda: self.save_note_text())

    @pyqtSlot(str)
    def change_open_note(self, sys_name, index): # МЕНЯЕТ АКТИВНУЮ ЗАМЕТКУ
        self.open_note_sys_name = str(sys_name)
        self.open_note_index = index
        if self.open_note_index == -1:
            self.show_main_note_text()
        else:
            self.show_note_text()
        self.create_all_img_button()
        self.change_buttons()

    def change_buttons(self):
        if self.open_note_index == -1:
            self.clipButton.hide()
            self.plusButton.show()
        else:
            self.clipButton.show()
            self.plusButton.hide()

    #-------------------------Fuctions for open and save text-------------------------
    @pyqtSlot(str)
    def save_note_text(self):  # УНИВЕРСАЛЬНАЯ СОХРАНЯЛКА JSON ФАЙЛОВ
        note_sys_name = self.open_note_sys_name
        index = self.open_note_index
        text = self.textedit.toPlainText()
        self.notes_dict_list[index]["text"] = text
        self.notes_dict_list[index]["date"] = self.note_date_func()
        notes_dict_copy = self.notes_dict_list[index].copy()
        del notes_dict_copy["note_layout"]
        if "images_btn" in notes_dict_copy.keys():
            del notes_dict_copy["images_btn"]
        with open(self.path + "\\" + note_sys_name + ".json", 'w') as f:
            json.dump(notes_dict_copy, f)
    
    def save_main_note_text(self):
        text = self.textedit.toPlainText()
        self.main_dict["text"] = text
        self.main_dict["date"] = self.note_date_func()
        with open(self.path + "\\" + "MainNote.json", 'w') as f:
            json.dump(self.main_dict, f)
    
    @pyqtSlot(str)
    def open_text(self, index):  # УНИВЕРСАЛЬНАЯ ОТКРЫВАЛКА JSON ФАЙЛОВ
        if index != -1:
            return self.notes_dict_list[index]["text"]
        else:
            return self.main_dict["text"]

    #-------------------------Fuctions for self.plusButton-------------------------
    def max_note_name_number(self): # ВОЗВРАЩАЕТ МАКИСМАЛЬНЫЙ НОМЕР NONAME ЗАМЕТОК
        a = []
        for note in self.notes_dict_list:
            if note["user_name"][:6] == "NoName":
                a.append(int(note["user_name"][6:]))
        if a:
            return max(a)
        else:
            return 0
    
    def input_note_name(self): # ввод названия заметки
        name, ok = QInputDialog.getText(self, "Naming", "Enter name",
                                        text="NoName" + str(self.max_note_name_number() + 1))
        note_user_name = None
        if ok and name != "":
            note_user_name = str(name)
        elif ok and name == "":
            note_user_name = "NoName" + str(self.max_note_name_number() + 1)
        else:
            return None
        return note_user_name
    
    def input_note_hashtag(self):
        text, ok = QInputDialog.getText(self, "Hashtag", "Enter hashtag", text="#noname")
        note_hashtag = None
        if ok and text != "":
            text = text.replace(" ", "")
            text = text.lower()
            if text[0] != "#":
                text = "#" + text
            note_hashtag = str(text)
        elif ok and text == "":
            note_hashtag = "#noname"
        else:
            return None
        return  note_hashtag
    
    @pyqtSlot()
    def new_note(self):  # СОЗДАНИЕ НОВОЙ КНОПКИ ЗАМЕТКИ
        new_note_user_name = self.input_note_name()

        if new_note_user_name == None:
            return

        new_note_hashtag = self.input_note_hashtag()

        if new_note_hashtag == None:
            return

        self.notes_count += 1
        index = self.notes_count - 1
        new_sys_name = "Note" + str(self.notes_count)

        # создание дизайна и добавление подзаметки
        memoLayout = QVBoxLayout()

        mainGroupBox = QGroupBox()
        mainGroupBox.setGeometry(QRect(300, 160, 261, 251))
        mainGroupBox.setMaximumSize(QSize(300, 300))
        mainGroupBox.setStyleSheet("border-radius: 10px;\n"
"background-color: rgb(83,90,87);")

        mainVerticalLayout = QVBoxLayout(mainGroupBox)
        mainVerticalLayout.setContentsMargins(0, 0, 0, 0)

        topGroupBox = QGroupBox(mainGroupBox)
        topGroupBox.setStyleSheet("background-color: rgb(0, 0, 0);\n"
"font: 87 9pt \"Arial Black\";\n"
"color: white;")

        topHorizontalLayout = QHBoxLayout(topGroupBox)

        nameLabel = QLabel(topGroupBox) # name
        nameLabel.setText(new_note_user_name)
        topHorizontalLayout.addWidget(nameLabel)
        hashtagLabel = QLabel(topGroupBox) #hashtag
        hashtagLabel.setStyleSheet("color: white;")
        hashtagLabel.setText(new_note_hashtag)
        topHorizontalLayout.addWidget(hashtagLabel)

        toolButton = QToolButton()
        toolButton.setCursor(QCursor(Qt.PointingHandCursor))
        toolButton.setCheckable(False)
        toolButton.setAutoRepeat(False)
        toolButton.setAutoExclusive(False)
        toolButton.setAutoRaise(False)
        toolButton.setText( "...")

        toolMenu = QMenu(toolButton)

        removeAction = QAction('Remove')
        removeAction.triggered.connect(lambda: self.note_del(index=index, note_layout=memoLayout, note_hashtag=new_note_hashtag,
                                                              sys_name=new_sys_name, user_name=new_note_user_name))
        toolMenu.addAction(removeAction)

        renameAction = QAction('Rename')
        renameAction.triggered.connect(lambda: self.rename_note(new_sys_name, new_note_hashtag, index, new_note_user_name))
        toolMenu.addAction(renameAction)

        openAction = QAction("Open")
        openAction.triggered.connect(lambda: self.show_note_box(sys_name=new_sys_name, index=index))
        toolMenu.addAction(openAction)

        toolButton.setMenu(toolMenu)

        topHorizontalLayout.addWidget(toolButton)
        mainVerticalLayout.addWidget(topGroupBox)

        textGroupBox = QGroupBox(mainGroupBox)
        verticalLayout = QVBoxLayout(textGroupBox)
        verticalLayout.setContentsMargins(9, 0, 9, 9)

        textEdit = QTextEdit(textGroupBox)
        textEdit.setMinimumSize(QSize(200, 150))
        textEdit.setMaximumSize(QSize(300, 400))

        textEdit.setStyleSheet("font:12pt 'sans-serif';\n"
"background-color: rgb(230,216,203);\n"
"color: black;")
        textEdit.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:7.8pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Note\'s name...</p></body></html>")
        verticalLayout.addWidget(textEdit)
        mainVerticalLayout.addWidget(textGroupBox)

        memoLayout.addWidget(mainGroupBox)
        memoLayout.addLayout(mainVerticalLayout)

        # Создание заметки в левой менюшке
        if not new_note_hashtag in self.hash_dict:
            new_root_item = QTreeWidgetItem()
            new_root_item.setText(0, new_note_hashtag)
            new_item = QTreeWidgetItem()
            new_item.setText(0, new_note_user_name)
            new_root_item.addChild(new_item)
            self.tree.addTopLevelItem(new_root_item)
            self.tree.itemDoubleClicked.connect(self.double_click_on_item)
            self.hash_dict[new_note_hashtag] = []
            self.hash_dict[new_note_hashtag].append({"user_name": new_note_user_name, "note_item": new_item})
        else:
            self.hash_dict["{}".format(new_note_hashtag)].append({"user_name": new_note_user_name, "note_item": ""})
            self.tree.clear()
            self.cycle_for_items()

        # добавляем в список новую заметку в виде словаря
        new_note_dict = {"user_name": new_note_user_name, "sys_name": new_sys_name, "text": "", "index": index,
                         "date": self.note_date_func(), "hashtag": new_note_hashtag, "note_layout": memoLayout}
                                                                            # та же история, что и сверху
                                                                            # нужно ли добавлять один только групп бокс
                                                                            # или будем добавлять кортеж:
                                                                            # mainGroupBox, verticalLayout,
        self.notes_dict_list.append(new_note_dict)

        # подключаем все функции к кнопке
        # new_note_layout.leftClick.connect(lambda: self.show_note_text(new_sys_name, index))
        #new_note_layout.rightClick.connect(lambda: self.context_menu(new_note_layout, new_note_hashtag, index, new_sys_name, new_note_user_name))
        # new_note_layout.clicked.connect(self.show_note_img)
        # new_note_layout.destroyed.connect(lambda: self.del_print(new_note_user_name))

        # сохраняем словарь в json файл
        text = '{{"user_name": "{}", "sys_name": "{}", "text": "", "index": {}, "date": "{}", "hashtag": "{}"}}'.format(
            new_note_user_name, new_sys_name, index, self.note_date_func(), new_note_hashtag)

        with open(self.path + r'\{}'.format(new_sys_name) + '.json', 'w+') as f:
            f.write(text)

        # добаляем виджет поздаметки
        self.noteLayout.addLayout(memoLayout)
        # self.noteLayout.addWidget(mainGroupBox)
        # self.noteLayout.addLayout(verticalLayout)

        # открываем и активируем заметку
        self.change_open_note(new_sys_name, index)
        # self.show_note_text()
        # self.note_name_lbl_func(new_note_user_name)


        print(self.notes_dict_list)

    # -------------------------Functions for context menu-------------------------
    @pyqtSlot("QPushButton", str)
    def context_menu(self, note_layout, note_hashtag, index, sys_name, user_name): # СОЗДАЕТ КОНТЕКСТНОЕ МЕНЮ
        print("context menu:", note_layout, note_hashtag, index, sys_name, user_name)
        self.menu = QMenu()

        removeAct = QAction('Delete', self)
        removeAct.triggered.connect(lambda: self.note_del(index=index, note_layout=note_layout, note_hashtag=note_hashtag, sys_name=sys_name,
                                                          user_name=user_name))
        renameAct = QAction('Rename', self)
        renameAct.triggered.connect(lambda: self.rename_note(sys_name, note_hashtag, index, user_name))

        self.menu.addAction(removeAct)
        self.menu.addAction(renameAct)
        self.menu.addSeparator() # вообще не знаю че это даже не смотри

        note_layout.customContextMenuRequested.connect(lambda: self.show_context_menu())

    @pyqtSlot()
    def show_context_menu(self): # ОТОБРАЖАЕТ КОНТЕКСТНОЕ МЕНЮ
        # Показываем меню и выбираем ему место
        self.menu.exec_(QCursor.pos())

    @pyqtSlot(str, "QPushButton", int)
    def rename_note(self, sys_name, note_hashtag, index, user_name): # ПЕРЕИМЕНОВАНИЕ ЗАМЕТКИ
        # пользователь вводит новое название заметки
        text, ok = QInputDialog.getText(self, "Naming", "Enter name", text=user_name)

        if ok and text != "":
            note_name = str(text)
        else:
            return None

        # переименовываем заметки в левом меню
        for i in range(len(self.hash_dict[note_hashtag])):
            if self.hash_dict[note_hashtag][i]["user_name"] == self.notes_dict_list[index]["user_name"]:
                self.hash_dict[note_hashtag][i]["user_name"] = note_name
        self.tree.clear()
        self.cycle_for_items()

        # меняем название в словаре
        self.notes_dict_list[index]["user_name"] = note_name
        d = self.notes_dict_list[index].copy()
        del d["note_layout"]
        if "images_btn" in d.keys():
            del d["images_btn"]
        # меняем название в json файле
        with open(self.path + "\\" + sys_name + ".json", 'w') as f:
            json.dump(d, f)

        self.note_name_lbl_func(sys_name)  # устанавливаем название на label сверху
        self.show_note_text(sys_name, index)  # открываем заметку
        self.notes_dict_list[index]["date"] = self.note_date_func()  # устанавливаем время изменения заметки

    @pyqtSlot("QPushButton", int, str)
    def note_del(self, note_layout, index, note_hashtag, sys_name, user_name): # УДАЛЯЕТ ПОДЗАМЕТКУ
        from shutil import move
        print("delete:", note_layout, index, note_hashtag, sys_name, user_name)

        # удаляем заметку из левого меню
        for note in self.hash_dict[note_hashtag]:
            if note["user_name"] == self.notes_dict_list[index]["user_name"]:
                self.hash_dict[note_hashtag].remove(note)

        self.notes_dict_list.pop(index)  # удаляем заметку заметку из списка
        self.notes_count = self.notes_count - 1  # уменьшаем кол-во заметок

        if self.hash_dict[note_hashtag] == []: # если в хэштэге больше нет заметок, то удаляем хэштег
            del self.hash_dict[note_hashtag]

        self.tree.clear() # удаляем заметки из меню
        self.cycle_for_items() # заново добавляем заметки в меню

        # удаляем виджет кнопки и json
        self.clear_layout(note_layout)
        self.clear_layout(self.imgLayout)
        self.clear_layout(self.audioLayout)
        note_layout.deleteLater()

        os.remove(self.path + r"\{}".format(sys_name) + ".json")

        # открываем главную заметку
        self.change_open_note("MainNote", -1)

        # переименуем файлы json (-1)
        i = index + 2
        while os.path.exists(self.path + r"\Note" + str(i) + ".json"):
            move(self.path + r"\Note" + str(i) + ".json", self.path + r"\Note" + str(i - 1) + ".json")
            i += 1

        # перенумеруем заметки в списке (-1)
        for note_dict in self.notes_dict_list[index:]:
            note_dict["index"] = note_dict["index"] - 1
            note_dict["sys_name"] = note_dict["sys_name"][:4] + str(note_dict["index"]+ 1)
            d = note_dict.copy()
            del d["note_layout"]
            with open(self.path + r"\{}".format(sys_name) + ".json", 'w+') as f:
                json.dump(d, f)

        print(self.notes_dict_list)

    def clear_layout(self, layout):
        # for widget in reversed(range(layout.count())): #очищает все виджеты с лэйаута
        #     layout.itemAt(widget).widget().setParent(None)
        # layout.deleteLater()

        if layout != None:
            while layout.count():
                item = layout.takeAt(0)
                if item.widget != None:
                    item.widget().setParent(None)
                elif item.layout != None:
                    self.deleteLayout(item.layout())
                    return

    #-------------------------Functions for tree menu-------------------------
    def cycle_for_items(self): # ЗАНОВО СОЗДАЕТ ЗАМЕТКИ В ЛЕВОМ МЕНЮ ПО КАТЕГОРИЯМ
        items_lst = []
        for key in self.hash_dict:
            root_item = QTreeWidgetItem()
            root_item.setText(0, key)
            for i in self.hash_dict[key]:
                item = QTreeWidgetItem()
                item.setText(0, i["user_name"])
                root_item.addChild(item)
                i["note_item"] = item
            items_lst.append(root_item)
        self.tree.addTopLevelItems(items_lst)
        self.tree.itemDoubleClicked.connect(self.double_click_on_item)

    def double_click_on_item(self, item): # ОТКРЫВАЕТ ЗАМЕТКУ ПРИ ДВОЙНОМ КЛИКЕ В ЛЕВОЙ МЕНЮХЕ
        name = item.text(0)
        for note in self.notes_dict_list:
            if note["user_name"] == str(name) :
                self.change_open_note(note["sys_name"], note["index"])

    def tree_context_menu(self, position): # СОЗДАЕТ КОНТЕКСТНОЕ МЕНЮ ДЛЯ ЛЕВОГО МЕНЮ
        item = self.tree.itemAt(position)
        if item != None:
            for hashtag in self.hash_dict:
                for note in self.hash_dict[hashtag]:
                    if note["note_item"] == item:
                        user_name = note["user_name"]
                        i = 0
                        while user_name != self.notes_dict_list[i]["user_name"]:
                            i += 1
                        print(self.notes_dict_list[i]["index"])
                        index = self.notes_dict_list[i]["index"]
                        note_layout = self.notes_dict_list[i]["note_layout"]
                        note_hashtag = self.notes_dict_list[i]["hashtag"]
                        sys_name = self.notes_dict_list[i]["sys_name"]

            self.tree_menu = QMenu()

            removeAct = QAction('Delete', self)
            removeAct.triggered.connect(
                lambda: self.note_del(index=index, note_layout=note_layout, note_hashtag=note_hashtag, sys_name=sys_name,
                                      user_name=user_name))
            renameAct = QAction('Rename', self)
            renameAct.triggered.connect(lambda: self.rename_note(sys_name, note_layout, note_hashtag, index, user_name))

            self.tree_menu.addAction(removeAct)
            self.tree_menu.addAction(renameAct)
            self.tree_menu.addSeparator()  # вообще не знаю че это даже не смотри

            self.tree_menu.exec_(self.tree.viewport().mapToGlobal(position))

    @pyqtSlot()
    def show_tree_context_menu(self):  # ОТОБРАЖАЕТ КОНТЕКСТНОЕ МЕНЮ
        # Показываем меню и выбираем ему место
        self.tree_menu.exec_(QCursor.pos())

    def show_left_menu(self):
        if self.frame_menu.isVisible() == True:
            self.frame_menu.setVisible(False)
        else:
            self.frame_menu.setVisible(True)

    def check_for_added_image(self, img_name):
        if ("images" in self.notes_dict_list[self.open_note_index].keys()) and (img_name in self.notes_dict_list[self.open_note_index]["images"]):
                errorMessage = QMessageBox()
                errorMessage.setIcon(QMessageBox.Critical)
                errorMessage.setText("This image has already been added to the {}.".format(self.notes_dict_list[self.open_note_index]["user_name"]))
                errorMessage.setWindowTitle("Error")
                return errorMessage
        else:
            return None


    #-------------------------Functions for image-------------------------
    @pyqtSlot(str)
    def add_img(self): # ДОБАВЛЯЕТ КАРТИНКУ В АКТИВНУЮ ЗАМЕТКУ
        fileName, _ = QFileDialog.getOpenFileName(None, "Select Image", "",
                                                            "Image Files (*.png *.jpg *jpeg *.bmp)")
        if not fileName:
            return None

        errorMessage = self.check_for_added_image(fileName)
        if errorMessage:
            errorMessage.exec_()
            return

        img_button = QPushButton()
        # img_button.clicked.connect(self.openImage)
        img_button.setGeometry(QRect(100, 100, 100, 100))
        img_button.setIcon(QIcon(fileName))
        img_button.setIconSize(QSize(img_button.width(), img_button.height()))

        self.imgLayout.addWidget(img_button)

        # self.open_img_btn.setIcon(QIcon(fileName))
        # self.open_img_btn.setIconSize(QSize(self.open_img_btn.width(), self.open_img_btn.height()))

        if not "images" in self.notes_dict_list[self.open_note_index].keys():
            self.notes_dict_list[self.open_note_index]["images"] = []
        self.notes_dict_list[self.open_note_index]["images"].append(fileName)

        if not "images_btn" in self.notes_dict_list[self.open_note_index].keys():
            self.notes_dict_list[self.open_note_index]["images_btn"] = []
        self.notes_dict_list[self.open_note_index]["images_btn"].append(img_button)

        note_dict_copy = self.notes_dict_list[self.open_note_index].copy()
        del note_dict_copy["note_layout"]
        if "images_btn" in note_dict_copy.keys():
            del note_dict_copy["images_btn"]

        with open(self.path + "\\" + self.open_note_sys_name + ".json", "w") as f:
            json.dump(note_dict_copy, f)

    def openImage(self):
        if self.mainFrame.isVisible():
            self.mainFrame.setVisible(False)
        else:
            self.mainFrame.setVisible(True)

    def create_all_img_button(self):
        for widget in reversed(range(self.imgLayout.count())): #очищает все виджеты с лэйаута
            self.imgLayout.itemAt(widget).widget().deleteLater()
        if (self.open_note_index == -1) and ("images" in self.main_dict.keys()):
            print("create_all_img_button")
            for img in self.main_dict["images"]:
                img_button = QPushButton()
                img_button.setGeometry(QRect(100, 100, 100, 100))
                img_button.setIcon(QIcon(img))
                img_button.setIconSize(QSize(img_button.width(), img_button.height()))
                self.imgLayout.addWidget(img_button)

        elif (self.open_note_index != -1) and ("images" in self.notes_dict_list[self.open_note_index].keys()):
            for img in self.notes_dict_list[self.open_note_index]["images"]:
                img_button = QPushButton()
                img_button.setGeometry(QRect(100, 100, 100, 100))
                img_button.setIcon(QIcon(img))
                img_button.setIconSize(QSize(img_button.width(), img_button.height()))
                self.imgLayout.addWidget(img_button)


    # -------------------------Other functions-------------------------
    def del_print(self, user_name):
        print("Удаляется", user_name)

    def note_date_func(self): # ВОЗВРАЩАЕТ ТЕКУЩЕЕ ВРЕМЯ В ВИДЕ СТРОКИ
        import datetime
        time_now = str(datetime.datetime.now())[:19]
        # year = time_now[:4]
        # month = time_now[4:7]
        # day = time_now[7:10]
        # hours = time_now[11:13]
        # minutes = time_now[13:16]
        # seconds = time_now[16:19]
        return time_now

    @pyqtSlot()
    def add_table(self):

        table = QTableWidget(self)  # Создаем таблицу

        columns, ok = QInputDialog.getInt(self, 'Input Dialog', 'Enter the number of columns: ')
        if ok:
            table.setColumnCount(columns)  # Устанавливаем кол-во столбцов

        rows, ok = QInputDialog.getInt(self, 'Input Dialog', 'Enter the number of rows: ')
        if ok:
            table.setRowCount(rows)  # Устанавливаем кол-во строк

        # Устанавливаем заголовки таблицы
        headers = []
        for i in range(columns):
            headers.append('Header %s' % (i + 1))

        table.setHorizontalHeaderLabels(headers)

        # Устанавливаем всплывающие подсказки на заголовки
        for i in range(columns):
            table.horizontalHeaderItem(i).setToolTip('Column %s' % (i + 1))

        # Устанавливаем выравнивание на заголовки
        for i in range(columns):
            table.horizontalHeaderItem(i).setTextAlignment(Qt.AlignHCenter)

        # заполняем первую строку
        for i in range(columns):
            table.setItem(0, i, QTableWidgetItem('Text in column %s' % (i + 1)))

        # делаем ресайз колонок по содержимому
        table.resizeColumnsToContents()

        table.doubleClicked.connect(self.on_click)  # пока ничего не делает

        self.widgetLay.addWidget(table)  # Добавляем таблицу в сетку

    def on_click(self):
        pass

    def add_title(self, textW):
        textW.acceptRichText(True)

        textW.toHTML("<h1><font></font></h1>")

    def add_audio(self):
        file = QFileDialog.getOpenFileName(parent=self,
                                          caption="Выберите файл")
        url = QUrl(file[0])
        file_name = ""
        if self.open_note_index == -1:
            self.main_dict["audio"] = file[0]
            self.main_dict["date"] = self.note_date_func()
            with open(self.path + "\\" +"MainNote.json", 'w') as f:
                json.dump(self.main_dict, f)
        else:
            self.notes_dict_list[self.open_note_index]["audio"] = file[0]
            self.notes_dict_list[self.open_note_index]["date"] = self.note_date_func()
            d = self.notes_dict_list[self.open_note_index].copy()
            del d["note_layout"]
            if "images_btn" in d.keys():
                del d["images_btn"]
            with open(self.path + "\\" + self.open_note_sys_name + ".json", 'w') as f:
                json.dump(d, f)

        playWidget = AudioPlayer(file[0], url)
        self.widgetLay.addWidget(playWidget)



    # def save_all_json(self): # ТЕСТОВАЯ ФУНКЦИЯ СОХРАНЕНИЯ JSON ПРИ ЗАКРЫТИИ ПРИЛОЖЕНИЯ
    #     for dict in self.notes_dict_list:
    #         with open(self.path + "\\" + "Note" + str(dict["number"]) + ".json", 'w') as f:
    #             json.dump(dict, f)
    #     with open(self.path + "\\" + "MainNote" + ".json", 'w') as f:
    #         json.dump(self.main_dict, f)
    #
    # def closeEvent(self, event):
    #     self.save_all_json()

def setup_thread_excepthook(): # ФУНКЦИЯ ДЛЯ ОБРАБОТКИ ВСЕХ ИСКЛЮЧЕНИЙ
    from threading import Thread
    init_original = Thread.__init__

    def init(self, *args, **kwargs):

        init_original(self, *args, **kwargs)
        run_original = self.run

        def run_with_except_hook(*args2, **kwargs2):
            try:
                run_original(*args2, **kwargs2)
            except Exception:
                sys.excepthook(*sys.exc_info())

        self.run = run_with_except_hook

    Thread.__init__ = init

if __name__ == '__main__':
    sys.excepthook = setup_thread_excepthook()
    app = QApplication(sys.argv)
    app.processEvents()

    # DESIGN
    app.setStyle("Fusion")
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ToolTipBase, Qt.white)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)

    demo = Notes()
    demo.show()
    sys.exit(app.exec_())
