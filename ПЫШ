import sys, os, json
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5 import QtMultimedia


class AudioPlayer(QWidget):
    def __init__(self, audio: str, file_, deleteAction=None, parent=None):
        QWidget.__init__(self, parent, flags=
        Qt.Window | Qt.MSWindowsFixedSizeDialogHint)
        # создание плеера
        self.audioPlayer = QtMultimedia.QMediaPlayer()
        self.audioPlayer.setVolume(100)
        self.audioPlayer.mediaStatusChanged.connect(self.initPlayer)
        self.audioPlayer.stateChanged.connect(self.setPlayerState)
        mainLayout = QVBoxLayout()
        mediaHbox = QHBoxLayout()
        toolLayout = QHBoxLayout()
        # имя аудиозаписи
        audioName = QLineEdit(audio)
        toolLayout.addWidget(audioName)
        # tools
        toolButton = QToolButton()
        toolButton.setText('...')
        toolLayout.addWidget(toolButton)
        # кнопка Play
        self.btnPlay = QPushButton('Play')
        self.btnPlay.clicked.connect(self.audioPlayer.play)
        self.btnPlay.setEnabled(False)
        mediaHbox.addWidget(self.btnPlay)
        # Timeline
        self.sldPosition = QSlider(Qt.Horizontal)
        self.sldPosition.setMinimum(0)
        self.sldPosition.valueChanged.connect(self.audioPlayer.setPosition)
        self.audioPlayer.positionChanged.connect(self.sldPosition.setValue)
        self.audioPlayer.setMedia(QtMultimedia.QMediaContent(file_))
        self.sldPosition.setEnabled(False)
        mediaHbox.addWidget(self.sldPosition)

        mainLayout.addLayout(toolLayout)
        mainLayout.addLayout(mediaHbox)

        self.setLayout(mainLayout)
        self.resize(300, 50)

    def initPlayer(self, state):  # КОНСТРУКТОР ПЛЕЕРА
        if state == QtMultimedia.QMediaPlayer.LoadedMedia:  # состояние плеера при загрузке аудио

            self.audioPlayer.stop()
            self.btnPlay.setEnabled(True)
            # self.sldPosition.setEnabled(True)
            self.sldPosition.setMaximum(self.audioPlayer.duration())

        elif state == QtMultimedia.QMediaPlayer.EndOfMedia:  # при конце аудио
            self.audioPlayer.stop()

        elif state == QtMultimedia.QMediaPlayer.NoMedia or state == QtMultimedia.QMediaPlayer.InvalidMedia:
            # при отсуствии аудио
            self.sldPosition.setValue(0)
            self.sldPosition.setEnabled(False)
            self.btnPlay.setEnabled(False)

    def setPlayerState(self, state):  # ДЕЙСТВИЯ ПРИ НАЖАТИИ PLAY
        if state == QtMultimedia.QMediaPlayer.PlayingState:
            # при включенном аудио
            self.btnPlay.setEnabled(True)
            self.btnPlay.setText('Pause')
            self.btnPlay.clicked.connect(self.audioPlayer.pause)

        elif state == QtMultimedia.QMediaPlayer.PausedState:
            # при выключенном
            self.btnPlay.setEnabled(True)
            self.btnPlay.setText('Play')
            self.btnPlay.clicked.connect(self.audioPlayer.play)


class MyPushButton(QPushButton):
    """
    Переписанный класс QPushButton
    Создан для того, чтобы можно было разделять левый и правый щелчок мыши на два сигнала
    """
    rightClick = pyqtSignal()
    leftClick = pyqtSignal()

    def __init__(self, string):
        super(QPushButton, self).__init__(string)

    def mousePressEvent(self, event):
        if event.button() == Qt.RightButton:
            self.rightClick.emit()
        elif event.button() == Qt.LeftButton:
            self.leftClick.emit()

        QPushButton.mousePressEvent(self, event)


class Notes(QWidget):
    def __init__(self):
        super(Notes, self).__init__()

        # self.path = r"D:\PROGRAMMING\Notes_App\directory_for_notes"
        self.path = os.getcwd() #определяет директорию с .py файлом

        if not os.path.exists(self.path + r"\MainNote.json"):
            self.create_main_file()

        json_data = json.load(open(self.path + r'\MainNote.json', 'r+'))  # считываем данные с json файла
        jtopy = json.dumps(json_data)
        self.main_dict = json.loads(jtopy)  # КЛАДЕМ ДАННЫЕ В СЛОВАРЬ ГЛАВНОЙ ЗАМЕТКИ

        self.notes_dict_list = []  # СПИСОК С ЗАМЕТКАМИ
        i = 1
        while os.path.exists(self.path + r"\Note" + str(i) + ".json"):
            json_data = json.load(open(self.path + r"\Note" + str(i) + ".json", 'r+'))
            jtopy = json.dumps(json_data)
            note_dict = json.loads(jtopy)
            self.notes_dict_list.append(note_dict)
            i += 1

        self.notes_count = len(self.notes_dict_list)  # КОЛИЧЕСТВО ЗАМЕТОК

        self.initUI()

    def initUI(self):

        # Размеры
        self.setWindowTitle('Note')
        self.setGeometry(300, 200, 650, 450)

        # Нулевой слой
        self.ZLay = QVBoxLayout()
        self.setLayout(self.ZLay)

        # Первый слой
        self.mainLayout = QHBoxLayout()
        self.ZLay.addLayout(self.mainLayout)

        # Menu
        self.menuButton = MyPushButton("Menu")
        self.mainLayout.addWidget(self.menuButton)
        self.menuButton.leftClick.connect(self.show_left_menu)

        self.textFrame = QFrame()
        self.widgetFrame = QFrame()
        self.textFrame.setStyleSheet('border-radius:10px;')

        self.mainLayout.addWidget(self.textFrame)
        self.mainLayout.addWidget(self.widgetFrame)

        self.textLayout = QVBoxLayout()
        self.textFrame.setLayout(self.textLayout)

        self.widgetLay = QVBoxLayout()

        self.widgetFrame.setLayout(self.widgetLay)
        self.widgetFrame.hide()

        self.noteFrame = QFrame()
        self.noteLayout = QVBoxLayout()
        self.noteFrame.setLayout(self.noteLayout)
        self.mainLayout.addWidget(self.noteFrame)


        self.note_name_lbl = QLabel("MainNote")
        self.textLayout.addWidget(self.note_name_lbl)

        self.date_lbl = QLabel("Last Edit: " + self.main_dict["date"])
        self.textLayout.addWidget(self.date_lbl)

        self.mainTextEdit = QTextEdit()
        self.mainTextEdit.setFrameStyle(14)
        self.textLayout.addWidget(self.mainTextEdit)
        self.mainTextEdit.setStyleSheet("font:12pt 'sans-serif';\n"
"background-color: rgb(230,216,203);\n"
"color: black;")

        # -----------------
        # Кнопки
        self.buttonLayout = QHBoxLayout()

        # Левое меню
        self.frame_menu = QFrame()
        self.frame_menu.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)
        self.left_menu = QVBoxLayout()
        self.frame_menu.move(self.menuButton.x(),self.menuButton.y())
        self.tree = QTreeWidget()
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.tree_context_menu)
        self.left_menu.addWidget(self.tree)
        self.left_menu.addStretch()
        self.frame_menu.setLayout(self.left_menu)
        #self.mainLayout.addWidget(self.frame_menu)

        # Активная на данный момент заметка
        self.open_note_sys_name = 'MainNote'
        self.open_note_index = -1

        # Словарь для хранения заметок по хэштегам
        self.hash_dict = {}
        for i in self.notes_dict_list:
                self.hash_dict.update({i["hashtag"]:[]})
        for i in self.notes_dict_list:
            for key in self.hash_dict:
                if i["hashtag"] == key:
                    self.hash_dict[key].append({"user_name": i["user_name"], "note_item": ""})

        # Создание древовидного виджета для заметок по категориям
        self.cycle_for_items()

        # Начальный документ
        doc = QTextDocument()
        doc.setPlainText(self.open_text(-1))
        doc.contentsChanged.connect(lambda: self.save_main_note_text())
        doc.setDefaultStyleSheet("border-style: outset;\n"
"background-color: rgb(240,240,240);\n"
"border-radius:10px;\n")
        self.mainTextEdit.setDocument(doc)
        self.mainTextEdit.setFocus()  # устанавливает курсор в текстовое поле

        # Arrow
        self.homeButton = MyPushButton('Main Note')
        self.buttonLayout.addWidget(self.homeButton)
        self.homeButton.leftClick.connect(lambda: self.show_main_note_text())
        self.homeButton.leftClick.connect(lambda: self.change_open_note('MainNote', -1))

        # Plus
        self.plusButton = MyPushButton('Plus')
        self.buttonLayout.addWidget(self.plusButton)
        self.plusButton.leftClick.connect(lambda: self.new_note())
        self.plusButton.setShortcut("Ctrl+N")


        # Меню для кнопки-скрепки
        contextMenuForButton = QMenu()

        addImage = QAction('Image', self)
        addImage.triggered.connect(lambda: self.add_img())
        addAudio = QAction('Audio', self)
        addAudio.triggered.connect(lambda: self.add_audio())

        contextMenuForButton.addAction(addImage)
        contextMenuForButton.addAction(addAudio)
        contextMenuForButton.addSeparator()

        contextMenuForButton.customContextMenuRequested.connect(lambda: self.show_context_menu())

        # Screpka
        self.clipButton = MyPushButton('Screpka')
        self.clipButton.setMenu(contextMenuForButton)
        self.buttonLayout.addWidget(self.clipButton)

        self.ZLay.addLayout(self.buttonLayout)
        #self.scrollAr.addScrollBarWidget(self.ZLay)

        # Запускаем цикл
        self.change_open_note('MainNote', -1)
        self.cycle_all_notes()

    #todo-------------------------Functions for MainNote-------------------------
    def create_main_file(self):  # СОЗДАНИЕ ГЛАВНОЙ ЗАМЕТКИ
        text = '{{"text": "", "date": "{}"}}'.format(self.note_date_func())
        with open(self.path + r'\MainNote.json', 'w+') as f:
            f.write(text)

    @pyqtSlot()
    def show_main_note_text(self):  # ОТОБРАЖАЕТ ГЛАВНУЮ ЗАМЕТКУ
        main_txtEdit = QTextDocument()
        main_txtEdit.setPlainText(self.open_text(-1))
        main_txtEdit.setDefaultStyleSheet("border-style: outset;\n"
"background-color: rgb(240,240,240);\n"
"border-radius:10px;\n")
        self.mainTextEdit.setDocument(main_txtEdit)
        self.mainTextEdit.setFocus() # устанавливает курсор в текстовое поле
        self.note_name_lbl.setText("MainNote")
        self.date_lbl.setText("Last Edit: " + self.main_dict["date"])
        main_txtEdit.contentsChanged.connect(lambda: self.save_main_note_text())


    #todo-------------------------Functions for launching notes-------------------------
    @pyqtSlot()
    def cycle_all_notes(self):  # ПРОХОДИТСЯ ЦИКЛОМ ПО ВСЕМ ЗАМЕТКАМ
        for note in self.notes_dict_list:
            self.show_note_box(note["sys_name"], note["index"], note["user_name"], note["hashtag"])

    @pyqtSlot(str)
    def show_note_box(self, sys_name, index, user_name, hashtag):  # ОТОБРАЖАЕТ И АКТИВИРУЕТ КНОПКУ
        print(self.notes_dict_list)

        memoLayout = QVBoxLayout()

        mainGroupBox = QGroupBox()
        mainGroupBox.setGeometry(QRect(300, 160, 261, 251))
        mainGroupBox.setMaximumSize(QSize(300, 200))

        mainGroupBox.setStyleSheet("border-radius: 10px;\n"
                                   "background-color: rgb(83,90,87);\n"
                                   "")

        mainLayout = QVBoxLayout(mainGroupBox)
        mainLayout.setContentsMargins(0, 0, 0, 0)
        topGroupBox = QGroupBox(mainGroupBox)
        topGroupBox.setStyleSheet("background-color: rgb(0, 0, 0);\n"
                                  "font: 87 9pt \"Arial Black\";\n"
                                  "color: white;")
        topGroupBox.setMaximumSize(QSize(300, 200))

        topLayout = QHBoxLayout(topGroupBox)
        labelName = QLabel(topGroupBox)
        labelName.setText(user_name)

        topLayout.addWidget(labelName)
        labelHashtag = QLabel(topGroupBox)
        labelHashtag.setText(hashtag)

        topLayout.addWidget(labelHashtag)

        toolButton = QToolButton(popupMode=QToolButton.InstantPopup)
        toolButton.setText("...")
        toolButton.setCursor(QCursor(Qt.PointingHandCursor))
        toolButton.setCheckable(False)
        toolButton.setAutoRepeat(False)
        toolButton.setAutoExclusive(False)
        toolButton.setAutoRaise(False)

        toolMenu = QMenu(toolButton)
        toolButton.setMenu(toolMenu)

        self.active_note_menu(toolMenu, toolButton, index, memoLayout, hashtag, sys_name, user_name)

        topLayout.addWidget(toolButton)
        mainLayout.addWidget(topGroupBox)

        noteTextEdit = QTextEdit(mainGroupBox)
        noteTextEdit.setMinimumSize(QSize(100, 150))
        noteTextEdit.setMaximumSize(QSize(250, 200))
        noteTextEdit.setStyleSheet(
            "background-color: rgb(230,216,203); border-style: outset; font:12pt 'sans-serif'; color: black;")

        noteTextEdit.setHtml(
            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
            "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
            "p, li { white-space: pre-wrap; }\n"
            "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:7.8pt; font-weight:400; font-style:normal;\">\n"
            "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Note\'s name...</p></body></html>")

        noteTextEdit.setReadOnly(True)
        noteTextEdit.viewport().setCursor(Qt.ArrowCursor)
        noteText = self.open_text(index)
        if len(noteText) > 44:
            noteTextEdit.setText(noteText[:44] + "...")
        else:
            noteTextEdit.setText(noteText[:44])

        mainLayout.addWidget(noteTextEdit)

        memoLayout.addLayout(mainLayout)
        memoLayout.addWidget(mainGroupBox)
        self.noteLayout.addLayout(memoLayout)

        self.notes_dict_list[index]["note_layout"] = memoLayout
        self.notes_dict_list[index]["note_menu"] = toolMenu
        self.notes_dict_list[index]["note_tool_btn"] = toolButton
        self.notes_dict_list[index]["note_textedit"] = noteTextEdit
        self.notes_dict_list[index]["note_label_name"] = labelName
        self.notes_dict_list[index]["note_label_hashtag"] = labelHashtag

        print(self.notes_dict_list)

    def active_note_menu(self, menu, tool_btn, index, note_layout, hashtag, sys_name, user_name):
        """Очищает и заново запускает меню для заметки"""
        menu.clear()

        removeAction = QWidgetAction(tool_btn)
        removeAction.setText("Remove")
        removeAction.triggered.connect(
            lambda: self.note_del(index=index, note_layout=note_layout, note_hashtag=hashtag,
                                  sys_name=sys_name, user_name=user_name))
        menu.addAction(removeAction)

        renameAction = QWidgetAction(tool_btn)
        renameAction.setText("Rename")
        renameAction.triggered.connect(
            lambda: self.rename_note(sys_name, hashtag, index, user_name))
        menu.addAction(renameAction)

        openAction = QWidgetAction(tool_btn)
        openAction.setText("Open")
        openAction.triggered.connect(lambda: self.change_open_note(sys_name=sys_name, index=index))
        menu.addAction(openAction)

    @pyqtSlot(str)
    def show_note_text(self):  # СОЗДАЕТ ТЕСТОВОЕ ПОЛЕ QTEXTDOCUMENT И АКТИВИРУЕТ СОХРАНЕНИЕ
        note_doc = QTextDocument()
        note_doc.setPlainText(self.open_text(self.open_note_index))
        self.mainTextEdit.setDocument(note_doc)
        self.mainTextEdit.setFocus() # устанавливает курсор в текстовое поле
        self.date_lbl.setText("Last Edit: " + self.notes_dict_list[self.open_note_index]["date"])
        self.note_name_lbl.setText(self.notes_dict_list[self.open_note_index]["user_name"])
        note_doc.contentsChanged.connect(lambda: self.save_note_text())

    def change_note_textedit(self, index):
        """Меняет текст на виджете подзаметки"""
        noteText = self.open_text(index)
        if len(noteText) > 44:
            self.notes_dict_list[index]["note_textedit"].setText(noteText[:44] + "...")
        else:
            self.notes_dict_list[index]["note_textedit"].setText(noteText[:44])

    @pyqtSlot(str)
    def change_open_note(self, sys_name, index):  # МЕНЯЕТ АКТИВНУЮ ЗАМЕТКУ
        self.open_note_sys_name = str(sys_name)
        self.open_note_index = index

        if self.open_note_index == -1:
            self.show_main_note_text()
        else:
            self.clear_layout(self.widgetLay)
            self.show_note_text()
        self.create_all_img_button()
        self.create_all_audio_player()
        self.change_buttons()


    def change_buttons(self):
        if self.open_note_index == -1:
            self.widgetFrame.hide()
            self.noteFrame.show()
            self.clipButton.hide()
            self.plusButton.show()
        else:
            self.noteFrame.hide()
            self.widgetFrame.show()
            self.clipButton.show()
            self.plusButton.hide()

    #todo-------------------------Fuctions for open and save text-------------------------
    @pyqtSlot(str)
    def save_note_text(self):  # УНИВЕРСАЛЬНАЯ СОХРАНЯЛКА JSON ФАЙЛОВ
        note_sys_name = self.open_note_sys_name
        index = self.open_note_index
        text = self.mainTextEdit.toPlainText()
        self.notes_dict_list[index]["text"] = text
        self.notes_dict_list[index]["date"] = self.note_date_func()
        note_dict_copy = self.notes_dict_list[index].copy()
        del note_dict_copy["note_layout"]
        del note_dict_copy["note_menu"]
        del note_dict_copy["note_tool_btn"]
        del note_dict_copy["note_textedit"]
        del note_dict_copy["note_label_name"]
        del note_dict_copy["note_label_hashtag"]
        if "images_btn" in note_dict_copy.keys():
            del note_dict_copy["images_btn"]
        with open(self.path + "\\" + note_sys_name + ".json", 'w') as f:
            json.dump(note_dict_copy, f)
        self.change_note_textedit(index)

    def save_main_note_text(self):
        text = self.mainTextEdit.toPlainText()
        self.main_dict["text"] = text
        self.main_dict["date"] = self.note_date_func()
        with open(self.path + "\\" + "MainNote.json", 'w') as f:
            json.dump(self.main_dict, f)

    @pyqtSlot(str)
    def open_text(self, index):  # УНИВЕРСАЛЬНАЯ ОТКРЫВАЛКА JSON ФАЙЛОВ
        if index != -1:
            return self.notes_dict_list[index]["text"]
        else:
            return self.main_dict["text"]

    #todo-------------------------Fuctions for plusButton-------------------------
    def max_note_name_number(self): # ВОЗВРАЩАЕТ МАКИСМАЛЬНЫЙ НОМЕР NONAME ЗАМЕТОК
        a = []
        for note in self.notes_dict_list:
            if note["user_name"][:6] == "NoName":
                a.append(int(note["user_name"][6:]))
        if a:
            return max(a)
        else:
            return 0

    def input_note_name(self, text): # ввод названия заметки
        name, ok = QInputDialog.getText(self, "Naming", "Enter name",
                                        text=text)
        note_user_name = None
        if ok and name != "":
            note_user_name = str(name)
        elif ok and name == "":
            note_user_name = "NoName" + str(self.max_note_name_number() + 1)
        else:
            return None
        return note_user_name

    def input_note_hashtag(self):
        text, ok = QInputDialog.getText(self, "Hashtag", "Enter hashtag", text="#noname")
        note_hashtag = None
        if ok and text != "":
            text = text.replace(" ", "")
            text = text.lower()
            if text[0] != "#":
                text = "#" + text
            note_hashtag = str(text)
        elif ok and text == "":
            note_hashtag = "#noname"
        else:
            return None
        return  note_hashtag

    @pyqtSlot()
    def new_note(self):  # СОЗДАНИЕ НОВОЙ КНОПКИ ЗАМЕТКИ
        new_note_user_name = self.input_note_name("NoName" + str(self.max_note_name_number() + 1))

        if new_note_user_name == None:
            return

        new_note_hashtag = self.input_note_hashtag()

        if new_note_hashtag == None:
            return

        self.notes_count += 1
        index = self.notes_count - 1
        new_sys_name = "Note" + str(self.notes_count)

        # создание дизайна и добавление подзаметки
        memoLayout = QVBoxLayout()

        mainGroupBox = QGroupBox()
        mainGroupBox.setGeometry(QRect(300, 160, 261, 251))
        mainGroupBox.setMaximumSize(QSize(300, 200))

        mainGroupBox.setStyleSheet("border-radius: 10px;\n"
                                   "background-color: rgb(83,90,87);\n"
                                   "")

        mainLayout = QVBoxLayout(mainGroupBox)
        mainLayout.setContentsMargins(0, 0, 0, 0)
        topGroupBox = QGroupBox(mainGroupBox)
        topGroupBox.setStyleSheet("background-color: rgb(0, 0, 0);\n"
                                  "font: 87 9pt \"Arial Black\";\n"
                                  "color: white;")
        topGroupBox.setMaximumSize(QSize(300, 200))

        topLayout = QHBoxLayout(topGroupBox)
        labelName = QLabel(topGroupBox)
        labelName.setText(new_note_user_name)

        topLayout.addWidget(labelName)
        labelHashtag = QLabel(topGroupBox)
        labelHashtag.setText(new_note_hashtag)

        topLayout.addWidget(labelHashtag)

        toolButton = QToolButton(popupMode=QToolButton.InstantPopup)
        toolButton.setText("...")
        toolButton.setCursor(QCursor(Qt.PointingHandCursor))
        toolButton.setCheckable(False)
        toolButton.setAutoRepeat(False)
        toolButton.setAutoExclusive(False)
        toolButton.setAutoRaise(False)

        toolMenu = QMenu(toolButton)
        toolButton.setMenu(toolMenu)

        self.active_note_menu(toolMenu, toolButton, index, memoLayout, new_note_hashtag, new_sys_name, new_note_user_name)

        topLayout.addWidget(toolButton)
        mainLayout.addWidget(topGroupBox)

        noteTextEdit = QTextEdit(mainGroupBox)
        noteTextEdit.setMinimumSize(QSize(100, 150))
        noteTextEdit.setMaximumSize(QSize(250, 200))
        noteTextEdit.setStyleSheet(
            "background-color: rgb(230,216,203); border-style: outset; font:12pt 'sans-serif'; color: black;")

        noteTextEdit.setHtml(
            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
            "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
            "p, li { white-space: pre-wrap; }\n"
            "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:7.8pt; font-weight:400; font-style:normal;\">\n"
            "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Note\'s name...</p></body></html>")

        noteTextEdit.setReadOnly(True)
        noteTextEdit.viewport().setCursor(Qt.ArrowCursor)
        noteText = ""
        noteTextEdit.setText(noteText[:24])
        mainLayout.addWidget(noteTextEdit)

        memoLayout.addLayout(mainLayout)
        memoLayout.addWidget(mainGroupBox)
        self.noteLayout.addLayout(memoLayout)

        # Создание заметки в левой менюшке
        if not new_note_hashtag in self.hash_dict:
            new_root_item = QTreeWidgetItem()
            new_root_item.setText(0, new_note_hashtag)
            new_item = QTreeWidgetItem()
            new_item.setText(0, new_note_user_name)
            new_root_item.addChild(new_item)
            self.tree.addTopLevelItem(new_root_item)
            self.tree.itemDoubleClicked.connect(self.double_click_on_item)
            self.hash_dict[new_note_hashtag] = []
            self.hash_dict[new_note_hashtag].append({"user_name": new_note_user_name, "note_item": new_item})
        else:
            self.hash_dict["{}".format(new_note_hashtag)].append({"user_name": new_note_user_name, "note_item": ""})
            self.tree.clear()
            self.cycle_for_items()

        # добавляем в список новую заметку в виде словаря
        new_note_dict = {"user_name": new_note_user_name,
                         "sys_name": new_sys_name,
                         "text": "",
                         "index": index,
                         "date": self.note_date_func(),
                         "hashtag": new_note_hashtag,
                         "note_layout": memoLayout,
                         "note_menu": toolMenu,
                         "note_tool_btn": toolButton,
                         "note_textedit": noteTextEdit,
                         "note_label_name": labelName,
                         "note_label_hashtag": labelHashtag}

        self.notes_dict_list.append(new_note_dict)


        # сохраняем словарь в json файл
        text = '{{"user_name": "{}", "sys_name": "{}", "text": "", "index": {}, "date": "{}", "hashtag": "{}"}}'.format(
            new_note_user_name, new_sys_name, index, self.note_date_func(), new_note_hashtag)

        with open(self.path + r'\{}'.format(new_sys_name) + '.json', 'w+') as f:
            f.write(text)

        # открываем и активируем заметку
        self.change_open_note(new_sys_name, index)

        print(self.notes_dict_list)

    #todo-------------------------Functions for context menu-------------------------
    @pyqtSlot("QPushButton", str)


    @pyqtSlot(str, "QPushButton", int)
    def rename_note(self, sys_name, note_hashtag, index, user_name): # ПЕРЕИМЕНОВАНИЕ ЗАМЕТКИ
        # пользователь вводит новое название заметки
        new_user_name = self.input_note_name(text = user_name)
        if new_user_name == None:
            return

        # переименовываем заметки в левом меню
        for i in range(len(self.hash_dict[note_hashtag])):
            if self.hash_dict[note_hashtag][i]["user_name"] == self.notes_dict_list[index]["user_name"]:
                self.hash_dict[note_hashtag][i]["user_name"] = new_user_name
        self.tree.clear()
        self.cycle_for_items()

        self.notes_dict_list[index]["note_label_name"].setText(new_user_name)
        # меняем название в словаре
        self.notes_dict_list[index]["user_name"] = new_user_name
        note_dict_copy = self.notes_dict_list[index].copy()
        del note_dict_copy["note_layout"]
        del note_dict_copy["note_menu"]
        del note_dict_copy["note_tool_btn"]
        del note_dict_copy["note_textedit"]
        del note_dict_copy["note_label_name"]
        del note_dict_copy["note_label_hashtag"]
        if "images_btn" in note_dict_copy.keys():
            del note_dict_copy["images_btn"]
        # меняем название в json файле
        with open(self.path + "\\" + sys_name + ".json", 'w') as f:
            json.dump(note_dict_copy, f)

        # self.note_name_lbl.setText(note_name)
        # self.show_note_text(sys_name, index)  # открываем заметку
        self.notes_dict_list[index]["date"] = self.note_date_func()  # устанавливаем время изменения заметки

    @pyqtSlot("QPushButton", int, str)
    def note_del(self, note_layout, index, note_hashtag, sys_name, user_name): # УДАЛЯЕТ ПОДЗАМЕТКУ
        from shutil import move
        print("delete:", note_layout, index, note_hashtag, sys_name, user_name)

        # удаляем заметку из левого меню
        for note in self.hash_dict[note_hashtag]:
            if note["user_name"] == self.notes_dict_list[index]["user_name"]:
                self.hash_dict[note_hashtag].remove(note)

        self.notes_dict_list.pop(index)  # удаляем заметку заметку из списка
        self.notes_count = self.notes_count - 1  # уменьшаем кол-во заметок

        if self.hash_dict[note_hashtag] == []: # если в хэштэге больше нет заметок, то удаляем хэштег
            del self.hash_dict[note_hashtag]

        self.tree.clear() # удаляем заметки из меню
        self.cycle_for_items() # заново добавляем заметки в меню

        # удаляем виджет кнопки и json
        self.clear_layout(note_layout)
        note_layout.deleteLater()

        os.remove(self.path + r"\{}".format(sys_name) + ".json")

        # открываем главную заметку
        self.change_open_note("MainNote", -1)

        # переименуем файлы json (-1)
        i = index + 2
        while os.path.exists(self.path + r"\Note" + str(i) + ".json"):
            move(self.path + r"\Note" + str(i) + ".json", self.path + r"\Note" + str(i - 1) + ".json")
            i += 1

        # перенумеруем заметки в списке (-1)
        for note_dict in self.notes_dict_list[index:]:
            note_dict["index"] = note_dict["index"] - 1
            note_dict["sys_name"] = note_dict["sys_name"][:4] + str(note_dict["index"]+ 1)
            note_dict_copy = note_dict.copy()
            del note_dict_copy["note_layout"]
            del note_dict_copy["note_menu"]
            del note_dict_copy["note_tool_btn"]
            del note_dict_copy["note_textedit"]
            del note_dict_copy["note_label_name"]
            del note_dict_copy["note_label_hashtag"]
            if "images_btn" in note_dict_copy.keys():
                del note_dict_copy["images_btn"]
            with open(self.path + r"\{}".format(sys_name) + ".json", 'w+') as f:
                json.dump(note_dict_copy, f)

        self.after_delete_cycle_for_notes(index)

        print(self.notes_dict_list)

    def clear_layout(self, layout):
        # for widget in reversed(range(layout.count())): #очищает все виджеты с лэйаута
        #     layout.itemAt(widget).widget().setParent(None)
        # layout.deleteLater()

        if layout != None:
            while layout.count():
                item = layout.takeAt(0)
                if item.widget() != None:
                    item.widget().setParent(None)
                elif item.layout() != None:
                    self.clear_layout(item.layout())
                    return

    def after_delete_cycle_for_notes(self, index):
        """Проходится циклом по всем заметкам начиная с индекса удаленной заметки и
        заново запускает каждое меню заметки. Это нужно для того, чтобы не было херни с индексами и последующим
        удалением заметок"""
        for note in self.notes_dict_list[index:]:
            self.active_note_menu(menu = note["note_menu"],
                                  tool_btn = note["note_tool_btn"],
                                  index = note["index"],
                                  note_layout = note["note_layout"],
                                  hashtag = note["hashtag"],
                                  sys_name = note["sys_name"],
                                  user_name = note["user_name"])

    #todo-------------------------Functions for tree menu-------------------------
    def cycle_for_items(self): # ЗАНОВО СОЗДАЕТ ЗАМЕТКИ В ЛЕВОМ МЕНЮ ПО КАТЕГОРИЯМ
        items_lst = []
        for key in self.hash_dict:
            root_item = QTreeWidgetItem()
            root_item.setText(0, key)
            for i in self.hash_dict[key]:
                item = QTreeWidgetItem()
                item.setText(0, i["user_name"])
                root_item.addChild(item)
                i["note_item"] = item
            items_lst.append(root_item)
        self.tree.addTopLevelItems(items_lst)
        self.tree.itemDoubleClicked.connect(self.double_click_on_item)

    def double_click_on_item(self, item): # ОТКРЫВАЕТ ЗАМЕТКУ ПРИ ДВОЙНОМ КЛИКЕ В ЛЕВОЙ МЕНЮХЕ
        name = item.text(0)
        for note in self.notes_dict_list:
            if note["user_name"] == str(name) :
                self.change_open_note(note["sys_name"], note["index"])

    def tree_context_menu(self, position): # СОЗДАЕТ КОНТЕКСТНОЕ МЕНЮ ДЛЯ ЛЕВОГО МЕНЮ
        item = self.tree.itemAt(position)
        if item != None:
            for hashtag in self.hash_dict:
                for note in self.hash_dict[hashtag]:
                    if note["note_item"] == item:
                        user_name = note["user_name"]
                        i = 0
                        while user_name != self.notes_dict_list[i]["user_name"]:
                            i += 1
                        print(self.notes_dict_list[i]["index"])
                        index = self.notes_dict_list[i]["index"]
                        note_layout = self.notes_dict_list[i]["note_layout"]
                        note_hashtag = self.notes_dict_list[i]["hashtag"]
                        sys_name = self.notes_dict_list[i]["sys_name"]

            self.tree_menu = QMenu()

            removeAct = QAction('Delete', self)
            removeAct.triggered.connect(
                lambda: self.note_del(index=index, note_layout=note_layout, note_hashtag=note_hashtag, sys_name=sys_name,
                                      user_name=user_name))
            renameAct = QAction('Rename', self)
            renameAct.triggered.connect(lambda: self.rename_note(sys_name, note_layout, note_hashtag, index, user_name))

            self.tree_menu.addAction(removeAct)
            self.tree_menu.addAction(renameAct)
            self.tree_menu.addSeparator()  # вообще не знаю че это даже не смотри

            self.tree_menu.exec_(self.tree.viewport().mapToGlobal(position))

    @pyqtSlot()
    def show_tree_context_menu(self):  # ОТОБРАЖАЕТ КОНТЕКСТНОЕ МЕНЮ
        # Показываем меню и выбираем ему место
        self.tree_menu.exec_(QCursor.pos())

    def show_left_menu(self):
        if self.frame_menu.isVisible() == True:
            self.frame_menu.setVisible(False)
        else:
            self.frame_menu.setVisible(True)


    #todo-------------------------Functions for image-------------------------

    def check_for_added_image(self, img_name):
        if ("images" in self.notes_dict_list[self.open_note_index].keys()) and (img_name in self.notes_dict_list[self.open_note_index]["images"]):
                errorMessage = QMessageBox()
                errorMessage.setIcon(QMessageBox.Critical)
                errorMessage.setText("This image has already been added to the {}.".format(self.notes_dict_list[self.open_note_index]["user_name"]))
                errorMessage.setWindowTitle("Error")
                return errorMessage
        else:
            return None

    @pyqtSlot(str)
    def add_img(self):  # ДОБАВЛЯЕТ КАРТИНКУ В АКТИВНУЮ ЗАМЕТКУ
        fileName, _ = QFileDialog.getOpenFileName(None, "Select Image", "",
                                                  "Image Files (*.png *.jpg *jpeg *.bmp)")
        if not fileName:
            return None
        errorMessage = self.check_for_added_image(fileName)
        if errorMessage:
            errorMessage.exec_()
            return
        img_button = MyPushButton("")
        img_button.rightClick.connect(lambda: self.img_context_menu(img_button, self.open_note_index, fileName))
        img_button.leftClick.connect(lambda: self.openImage(fileName))
        img_button.setGeometry(QRect(100, 100, 100, 100))
        img_button.setIcon(QIcon(fileName))
        img_button.setIconSize(QSize(img_button.width(), img_button.height()))


        self.widgetLay.addWidget(img_button)

        if not "images" in self.notes_dict_list[self.open_note_index].keys():
            self.notes_dict_list[self.open_note_index]["images"] = []
        self.notes_dict_list[self.open_note_index]["images"].append(fileName)
        if not "images_btn" in self.notes_dict_list[self.open_note_index].keys():
            self.notes_dict_list[self.open_note_index]["images_btn"] = []
        self.notes_dict_list[self.open_note_index]["images_btn"].append(img_button)
        note_dict_copy = self.notes_dict_list[self.open_note_index].copy()
        del note_dict_copy["note_layout"]
        del note_dict_copy["note_menu"]
        del note_dict_copy["note_tool_btn"]
        del note_dict_copy["note_textedit"]
        del note_dict_copy["note_label_name"]
        del note_dict_copy["note_label_hashtag"]
        if "images_btn" in note_dict_copy.keys():
            del note_dict_copy["images_btn"]
        with open(self.path + "\\" + self.open_note_sys_name + ".json", "w") as f:
            json.dump(note_dict_copy, f)

    def img_context_menu(self, img_button, index, img_path): # СОЗДАЕТ КОНТЕКСТНОЕ МЕНЮ
        img_button.setContextMenuPolicy(Qt.CustomContextMenu)
        img_menu = QMenu()

        removeAct = QWidgetAction(img_button)
        removeAct.setText("Delete")
        removeAct.triggered.connect(lambda: self.image_delete(index, img_button, img_path))
        img_menu.addAction(removeAct)

        img_button.customContextMenuRequested.connect(lambda: self.show_context_menu(img_menu))

    @pyqtSlot()
    def show_context_menu(self, menu): # ОТОБРАЖАЕТ КОНТЕКСТНОЕ МЕНЮ
        # Показываем меню и выбираем ему место
        menu.exec_(QCursor.pos())


    def image_delete(self, index, img_button, img_path):
        i = 0
        while img_path != self.notes_dict_list[index]["images"][i]:
            i += 1
        del self.notes_dict_list[index]["images"][i]
        img_button.setParent(None)
        img_button.deleteLater()

    def openImage(self, fileName_):
        from ctypes import windll
        self.openImgFrame = QFrame()
        self.openImgFrame.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)
        screenSize1 = windll.user32.GetSystemMetrics(0)
        screenSize2 = windll.user32.GetSystemMetrics(1)
        self.openImgFrame.setFixedSize(0.8 * screenSize1, 0.8 * screenSize2)
        imgLay = QHBoxLayout()
        img_button = QPushButton()
        img_button.clicked.connect(self.openImgFrame.hide)
        # img_button.setGeometry(QRect(100, 100, 0.8*screenSize1, 0.8*screenSize2))
        img_button.setIcon(QIcon(fileName_))
        img_button.setIconSize(QSize(0.8 * screenSize1, 0.8 * screenSize2))
        # img_button.setIconSize(QSize(img_button.width(), img_button.height()))
        self.openImgFrame.setLayout(imgLay)
        imgLay.addWidget(img_button)
        self.openImgFrame.show()
        # if self.openImgFrame.isVisible():
        #     self.openImgFrame.setVisible(False)
        # else:
        #     self.openImgFrame.setVisible(True)

    def create_all_img_button(self):
        if (self.open_note_index != -1) and ("images" in self.notes_dict_list[self.open_note_index].keys()):
            for img in self.notes_dict_list[self.open_note_index]["images"]:
                img_button = MyPushButton("")
                img_button.setGeometry(QRect(100, 100, 100, 100))
                img_button.setIcon(QIcon(img))
                img_button.setIconSize(QSize(img_button.width(), img_button.height()))
                img_button.rightClick.connect(lambda: self.img_context_menu(img_button, self.open_note_index, img))
                img_button.leftClick.connect(lambda: self.openImage(img))
                self.widgetLay.addWidget(img_button)


    #todo-------------------------Functions for audio-------------------------

    def check_for_added_audio(self, audio_path):
        if ("audio" in self.notes_dict_list[self.open_note_index].keys()):
            for audio_dict in self.notes_dict_list[self.open_note_index]["audio"]:
                if audio_path == audio_dict["audio_path"]:
                    errorMessage = QMessageBox()
                    errorMessage.setIcon(QMessageBox.Critical)
                    errorMessage.setText("This audio has already been added to the {}.".format(self.notes_dict_list[self.open_note_index]["user_name"]))
                    errorMessage.setWindowTitle("Error")
                    return errorMessage
        else:
            return None

    def create_all_audio_player(self):
        if (self.open_note_index != -1) and ("audio" in self.notes_dict_list[self.open_note_index].keys()):
            for audio_dict in self.notes_dict_list[self.open_note_index]["audio"]:
                url = QUrl(audio_dict["audio_path"])
                playWidget = AudioPlayer(audio_dict["audio_name"], url)
                self.widgetLay.addWidget(playWidget)

    def add_audio(self):
        file = QFileDialog.getOpenFileName(parent=self,
                                           caption="Выберите файл")

        if not file[0]:
            return None
        errorMessage = self.check_for_added_audio(file[0])
        if errorMessage:
            errorMessage.exec_()
            return

        url = QUrl(file[0])
        last_slash_index = file[0].rfind("/")
        audio_name = file[0][last_slash_index+1:]
        if file[0] != '':
            if "audio" not in self.notes_dict_list[self.open_note_index].keys():
                self.notes_dict_list[self.open_note_index]["audio"] = []
            self.notes_dict_list[self.open_note_index]["audio"].append({"audio_name": audio_name, "audio_path": file[0]})
            self.notes_dict_list[self.open_note_index]["date"] = self.note_date_func()
            note_dict_copy = self.notes_dict_list[self.open_note_index].copy()
            del note_dict_copy["note_layout"]
            del note_dict_copy["note_menu"]
            del note_dict_copy["note_tool_btn"]
            del note_dict_copy["note_textedit"]
            del note_dict_copy["note_label_name"]
            del note_dict_copy["note_label_hashtag"]
            if "images_btn" in note_dict_copy.keys():
                del note_dict_copy["images_btn"]
            with open(self.path + "\\" + self.open_note_sys_name + ".json", 'w') as f:
                json.dump(note_dict_copy, f)
            playWidget = AudioPlayer(audio_name, url)
            self.widgetLay.addWidget(playWidget)


    #todo-------------------------Other functions-------------------------

    def note_date_func(self): # ВОЗВРАЩАЕТ ТЕКУЩЕЕ ВРЕМЯ В ВИДЕ СТРОКИ
        import datetime
        time_now = str(datetime.datetime.now())[:19]
        # year = time_now[:4]
        # month = time_now[4:7]
        # day = time_now[7:10]
        # hours = time_now[11:13]
        # minutes = time_now[13:16]
        # seconds = time_now[16:19]
        return time_now

    def on_click(self):
        pass

    def add_title(self, textW):
        textW.acceptRichText(True)

        textW.toHTML("<h1><font></font></h1>")


    # def save_all_json(self): # ТЕСТОВАЯ ФУНКЦИЯ СОХРАНЕНИЯ JSON ПРИ ЗАКРЫТИИ ПРИЛОЖЕНИЯ
    #     for dict in self.notes_dict_list:
    #         with open(self.path + "\\" + "Note" + str(dict["number"]) + ".json", 'w') as f:
    #             json.dump(dict, f)
    #     with open(self.path + "\\" + "MainNote" + ".json", 'w') as f:
    #         json.dump(self.main_dict, f)
    #
    # def closeEvent(self, event):
    #     self.save_all_json()

def setup_thread_excepthook(): # ФУНКЦИЯ ДЛЯ ОБРАБОТКИ ВСЕХ ИСКЛЮЧЕНИЙ
    from threading import Thread
    init_original = Thread.__init__

    def init(self, *args, **kwargs):

        init_original(self, *args, **kwargs)
        run_original = self.run

        def run_with_except_hook(*args2, **kwargs2):
            try:
                run_original(*args2, **kwargs2)
            except Exception:
                sys.excepthook(*sys.exc_info())

        self.run = run_with_except_hook

    Thread.__init__ = init

if __name__ == '__main__':
    sys.excepthook = setup_thread_excepthook()
    app = QApplication(sys.argv)
    app.processEvents()

    # DESIGN
    app.setStyle("Fusion")
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ToolTipBase, Qt.white)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)

    demo = Notes()
    demo.show()
    sys.exit(app.exec_())
