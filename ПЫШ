import sys, os, json
from PyQt5.QtWidgets import *

class Notes(QMainWindow):

    def __init__(self):
        super(Notes, self).__init__()

        self.layout = QVBoxLayout()
        centralWidget = QWidget()
        centralWidget.setLayout(self.layout)

        self.setCentralWidget(centralWidget)

        self.path = r"D:\PROGRAMMING\Notes_App\directory_for_notes"  # директория, в которой по умолчанию хранятся заметки
        if not os.listdir(self.path):  # проверка на пустоту директории
            self.create_main_file()  # если в директории ничего нет, то создаем главный файл

        self.line_list = ['lineEdit1'] #список с названиями строк
        self.line_count = 1 #количество строк
        self.main_list = [''] #список с текстами каждой строчки
        self.start_line(self.line_list[self.line_count-1]) #первую строку загоняем в функцию

    def start_line(self, line): #функция, отвечающая за функционал строки
        line = QLineEdit()
        exist_file = open(self.path + r'\MainNote.json', 'r')  # открываю файл для чтения
        s = exist_file.read()
        line_wout_par = s[2:2] + s[2:len(s) - 2]
        line.setMaxLength(52)  # дабы строка не была бесконечной
        line.setText(line_wout_par)
        line.textEdited.connect(lambda: self.save_text(line)) #вот так нужно передавать аргументы в функции в PyQt
                                                            #при использовании сигнала
        self.layout.addWidget(line)
        line.returnPressed.connect(self.create_new_lineEdit)

    def save_text(self, line_text):
        text = line_text.text()
        self.main_list[self.line_count - 1] = text
        with open(self.path + r'\MainNote.json', 'w') as f:
            json.dump(self.main_list, f)

    def create_main_file(self):
        text = ''
        with open(self.path + r'\MainNote.json', 'w+') as f:
            f.write(text)

    def create_new_lineEdit(self):
        self.line_count += 1
        self.main_list.append('')
        self.line_list.append('lineEdit' + str(self.line_count))
        self.start_line(self.line_list[self.line_count-1]) #после создания новой строки сразу кидаем ее в функцию start_line

    # эта штукенция в теории должна при достижении лимита на строку перекидывать на новую (не работает пока)
    def symbol_limit(self):
        text = self.u.text()
        symbol_num = 0
        for sym in text:
            symbol_num += 1
        if symbol_num == 53:
            self.create_new_lineEdit()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    form = Notes()
    form.show()
    sys.exit(app.exec_())
