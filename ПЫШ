from re import findall, search
import sys, os, json
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5 import QtMultimedia


class AudioPlayer(QWidget):
    """
    Created widget AudioPlayer
    """
    def __init__(self, audio: str, file_, parent=None):
        QWidget.__init__(self, parent, flags=
        Qt.Window | Qt.MSWindowsFixedSizeDialogHint)
        # Player Creating
        self.audioPlayer = QtMultimedia.QMediaPlayer()
        self.audioPlayer.setVolume(100)
        self.audioPlayer.mediaStatusChanged.connect(self.initPlayer)
        self.audioPlayer.stateChanged.connect(self.setPlayerState)

        mainLayout = QVBoxLayout()
        mediaHbox = QHBoxLayout()
        toolLayout = QHBoxLayout()
        # Audio name
        audioName = QLineEdit(audio)
        toolLayout.addWidget(audioName)
        # tools
        toolButton = QToolButton(popupMode=QToolButton.InstantPopup)
        toolButton.setText('...')
        toolLayout.addWidget(toolButton)
        toolMenu = QMenu()
        removeAct = QWidgetAction(toolButton)
        removeAct.setText('Delete')
        removeAct.triggered.connect(self.deleteLater)
        toolMenu.addAction(removeAct)
        toolButton.setMenu(toolMenu)
        # кнопка Play
        self.btnPlay = QPushButton()
        self.btnPlay.clicked.connect(self.audioPlayer.play)
        self.btnPlay.setStyleSheet('border-image: url("PlayButton.png")')
        self.btnPlay.setEnabled(False)
        self.btnPlay.setMaximumWidth(14)
        mediaHbox.addWidget(self.btnPlay)
        # Timeline
        self.sldPosition = QSlider(Qt.Horizontal)
        self.sldPosition.setMinimum(0)
        self.sldPosition.valueChanged.connect(self.audioPlayer.setPosition)
        self.audioPlayer.positionChanged.connect(self.sldPosition.setValue)
        self.audioPlayer.setMedia(QtMultimedia.QMediaContent(file_))
        self.sldPosition.setEnabled(False)
        mediaHbox.addWidget(self.sldPosition)

        mainLayout.addLayout(toolLayout)
        mainLayout.addLayout(mediaHbox)

        self.setLayout(mainLayout)
        self.setMaximumHeight(65)
        self.resize(300, 50)

    def initPlayer(self, state):  # КОНСТРУКТОР ПЛЕЕРА
        if state == QtMultimedia.QMediaPlayer.LoadedMedia:  # состояние плеера при загрузке аудио

            self.audioPlayer.stop()
            self.btnPlay.setEnabled(True)
            # self.sldPosition.setEnabled(True)
            self.sldPosition.setMaximum(self.audioPlayer.duration())

        elif state == QtMultimedia.QMediaPlayer.EndOfMedia:  # при конце аудио
            self.audioPlayer.stop()

        elif state == QtMultimedia.QMediaPlayer.NoMedia or state == QtMultimedia.QMediaPlayer.InvalidMedia:
            # при отсуствии аудио
            self.sldPosition.setValue(0)
            self.sldPosition.setEnabled(False)
            self.btnPlay.setEnabled(False)

    def setPlayerState(self, state):  # ДЕЙСТВИЯ ПРИ НАЖАТИИ PLAY
        if state == QtMultimedia.QMediaPlayer.PlayingState:
            # при включенном аудио
            self.btnPlay.setEnabled(True)
            self.btnPlay.setStyleSheet('border-image: url("PauseButton.png")')
            self.btnPlay.clicked.connect(self.audioPlayer.pause)

        elif state == QtMultimedia.QMediaPlayer.PausedState:
            # при выключенном
            self.btnPlay.setEnabled(True)
            self.btnPlay.setStyleSheet('border-image: url("PlayButton.png")')
            self.btnPlay.clicked.connect(self.audioPlayer.play)

class MyPushButton(QPushButton):
    """
    Переписанный класс QPushButton
    Создан для того, чтобы можно было разделять левый и правый щелчок мыши на два сигнала
    """
    rightClick = pyqtSignal()
    leftClick = pyqtSignal()

    def __init__(self, string):
        super(QPushButton, self).__init__(string)

    def mousePressEvent(self, event):
        if event.button() == Qt.RightButton:
            self.rightClick.emit()
        elif event.button() == Qt.LeftButton:
            self.leftClick.emit()

        QPushButton.mousePressEvent(self, event)

class MyHighlighter(QSyntaxHighlighter):
    def __init__(self, parent):
        super(MyHighlighter, self).__init__(parent)

        hashtagFormat = QTextCharFormat()
        hashtagFormat.setForeground(Qt.darkBlue)
        hashtagFormat.setFontWeight(QFont.Bold)

        pattern = "@" + r"\w+" + "@"

        self.highlightingRules = [(QRegExp(pattern), hashtagFormat)]

    def highlightBlock(self, text):
        for pattern, format in self.highlightingRules:
            expression = QRegExp(pattern)
            index = expression.indexIn(text)
            while index >= 0:
                len = expression.matchedLength()
                self.setFormat(index, len, format)
                index = expression.indexIn(text, index + len)

class Notes(QWidget):
    def __init__(self):
        super(Notes, self).__init__()

        self.path = os.getcwd() # defines the directory with .py file

        if not os.path.exists(self.path + r"\MainNote.json"):
            self.create_main_file()

        json_data = json.load(open(self.path + r'\MainNote.json', 'r+'))  # read JSON File data's
        jtopy = json.dumps(json_data)
        self.main_dict = json.loads(jtopy)  # Put data's in Main Note dict
        self.notes_dict_list = []  # Dict with note's
        i = 1
        while os.path.exists(self.path + r"\Note" + str(i) + ".json"):
            json_data = json.load(open(self.path + r"\Note" + str(i) + ".json", 'r+'))
            jtopy = json.dumps(json_data)
            note_dict = json.loads(jtopy)
            self.notes_dict_list.append(note_dict)
            i += 1

        self.notes_count = len(self.notes_dict_list)

        self.initUI()

    def initUI(self):

        self.setWindowTitle('Note')
        self.setGeometry(300, 200, 750, 600)

        # Zero Layer
        self.ZLay = QVBoxLayout()
        self.setLayout(self.ZLay)

        # Heading with main inf
        hatBox = QGroupBox()
        hatBox.setStyleSheet("color: rgb(255, 255, 255);\n"
        "background-color: rgb(0, 0, 0);\n"
        "border-radius: 10px;")
        self.hatLayout = QHBoxLayout()
        hatBox.setLayout(self.hatLayout)

        # Menu
        self.menuButton = MyPushButton("")
        self.menuButton.setStyleSheet('border-image: url("MenuButton.png")')
        self.menuButton.setMaximumHeight(34)
        self.menuButton.setMaximumWidth(34)
        self.menuButton.setMinimumHeight(20)
        self.menuButton.setMaximumWidth(20)
        self.menuButton.leftClick.connect(self.show_left_menu)
        self.hatLayout.addWidget(self.menuButton)

        # Active note name
        self.note_name_lbl = QLabel("MainNote")
        name_font = QFont()
        name_font.setBold(True)
        name_font.setItalic(True)
        self.note_name_lbl.setFont(name_font)
        self.hatLayout.addWidget(self.note_name_lbl)

        # Note Last Changes
        self.date_lbl = QLabel(self.main_dict["date"])
        self.hatLayout.addWidget(self.date_lbl)

        # Menu for Clip Button
        self.clipContextMenu = QMenu()

        addImage = QAction('Image', self)
        addImage.triggered.connect(lambda: self.add_img())
        addAudio = QAction('Audio', self)
        addAudio.triggered.connect(lambda: self.add_audio())

        self.clipContextMenu.addAction(addImage)
        self.clipContextMenu.addAction(addAudio)
        self.clipContextMenu.addSeparator()

        # Clip Button
        self.clipButton = MyPushButton('')
        self.clipButton.setMenu(self.clipContextMenu)
        self.clipButton.setMaximumWidth(18)
        self.clipButton.setMinimumHeight(21)
        self.clipButton.setStyleSheet('border-image: url("ClipButton.png")')
        self.hatLayout.addWidget(self.clipButton)

        self.ZLay.addWidget(hatBox)

        # Scroll Area for text and widgets
        self.scrollArea = QScrollArea()
        self.scrollArea.setWidgetResizable(True)
        self.scrollAreaWidgetContents = QWidget()
        self.scrollAreaWidgetContents.setStyleSheet('border-radius:100px')
        self.mainLayout = QHBoxLayout()
        self.scrollAreaWidgetContents.setLayout(self.mainLayout)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.ZLay.addWidget(self.scrollArea)

        # First Layer for text and widgets
        self.textFrame = QFrame()
        self.textFrame.setMinimumWidth(0.6*QDesktopWidget.width(self))
        self.widgetFrame = QFrame()
        self.widgetFrame.setMaximumWidth(0.4*QDesktopWidget.width(self))
        self.textFrame.setStyleSheet('border-radius:10px;')

        self.mainLayout.addWidget(self.textFrame)
        self.mainLayout.addWidget(self.widgetFrame)

        self.textLayout = QVBoxLayout()
        self.textFrame.setLayout(self.textLayout)

        # Layout for
        self.widgetLay = QVBoxLayout()
        self.widgetFrame.setLayout(self.widgetLay)
        self.widgetFrame.hide()

        self.noteFrame = QFrame()
        self.noteFrame.setMaximumWidth(0.3*QDesktopWidget.width(self))
        self.noteLayout = QVBoxLayout()
        self.noteFrame.setLayout(self.noteLayout)
        self.mainLayout.addWidget(self.noteFrame)

        self.mainTextEdit = QTextEdit()
        self.mainTextEdit.setFrameStyle(14)
        self.textLayout.addWidget(self.mainTextEdit)
        self.mainTextEdit.setStyleSheet("font:12pt 'sans-serif';\n"
"background-color: rgb(230,216,203);\n"
"color: black;")

        # Left Menu
        self.frame_menu = QFrame()
        self.frame_menu.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)
        self.left_menu = QVBoxLayout()
        self.frame_menu.move(self.x() + 38,self.y() + 71)
        self.tree = QTreeWidget()
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.tree_context_menu)
        self.left_menu.addWidget(self.tree)
        self.left_menu.addStretch()
        self.frame_menu.setLayout(self.left_menu)

        # Active Note
        self.open_note_sys_name = 'MainNote'
        self.open_note_index = -1

        # Dict for storage note
        self.reactive_hash_dict()
        # Tree widget creating for Notes categories
        self.cycle_for_items()

        # Initial Document
        doc = QTextDocument()
        doc.setPlainText(self.open_text(-1))
        doc.contentsChanged.connect(lambda: self.save_main_note_text())
        doc.setDefaultStyleSheet("border-style: outset;\n"
"background-color: rgb(240,240,240);\n"
"border-radius:10px;\n")
        self.mainTextEdit.setDocument(doc)
        self.mainTextEdit.setFocus()  # set Cursor in Text

        # -----------------
        # Buttons
        self.buttonLayout = QGridLayout()
        #elf.buttonLayout.addSpacing(2 * self.x())
        #self.buttonLayout.addSpacerItem(QSpacerItem(self.x() + 100, 0))

        #Home Button
        self.homeButton = MyPushButton('')
        self.buttonLayout.addWidget(self.homeButton, 0, 3)
        self.homeButton.leftClick.connect(lambda: self.show_main_note_text())
        self.homeButton.leftClick.connect(lambda: self.change_open_note('MainNote', -1))
        self.homeButton.setShortcut("Ctrl+W")
        self.homeButton.setStyleSheet('border-image: url("HomeButton.png"); border-radius: 40px 40px')
        self.homeButton.setMinimumWidth(55)
        self.homeButton.setMinimumHeight(50)
        self.homeButton.setMaximumWidth(45)
        self.homeButton.setMaximumHeight(40)
        self.homeButton.hide()


        # Plus
        self.plusButton = MyPushButton('')
        self.plusButton.setMinimumWidth(55)
        self.plusButton.setMinimumHeight(50)
        self.plusButton.setMaximumWidth(45)
        self.plusButton.setMaximumHeight(40)
        self.buttonLayout.addWidget(self.plusButton, 0, 10)
        self.plusButton.leftClick.connect(lambda: self.new_note())
        self.plusButton.setShortcut("Ctrl+N")
        self.plusButton.setStyleSheet('border-image: url("PlusButton.png");border-radius: 40px 40px')
        self.plusButton.move(self.x(), 0)

        self.ZLay.addLayout(self.buttonLayout)

        # Creating notes
        self.change_open_note('MainNote', -1)
        self.cycle_all_notes()

    #todo-------------------------Functions for MainNote-------------------------
    def create_main_file(self):  # СОЗДАНИЕ ГЛАВНОЙ ЗАМЕТКИ
        """
        File and dict of Main Note creating
        :return: JSON File with dict
        """
        text = '{{"text": "", "date": "{}"}}'.format(self.note_date_func())
        with open(self.path + r'\MainNote.json', 'w+') as f:
            f.write(text)

    @pyqtSlot()
    def show_main_note_text(self):
        """
        Represent Main note
        """
        main_txtEdit = QTextDocument()
        main_txtEdit.setPlainText(self.open_text(-1))
        main_txtEdit.setDefaultStyleSheet("border-style: outset;\n"
"background-color: rgb(240,240,240);\n"
"border-radius:10px;\n")
        self.mainTextEdit.setDocument(main_txtEdit)
        self.mainTextEdit.setFocus() # устанавливает курсор в текстовое поле
        self.note_name_lbl.setText("MainNote")
        self.date_lbl.setText("Last Edit: " + self.main_dict["date"])
        main_txtEdit.contentsChanged.connect(lambda: self.save_main_note_text())


    #todo-------------------------Functions for launching notes-------------------------
    @pyqtSlot()
    def cycle_all_notes(self):
        """
        Go through all notes
        """
        for note in self.notes_dict_list:
            self.show_note_box(note["sys_name"], note["index"], note["user_name"], note["hashtags"])

    @pyqtSlot(str)
    def show_note_box(self, sys_name, index, user_name, hashtags):
        """
        Create, save and represent note's widget

        :param sys_name: str
        :param index: int
        :param user_name: str
        :param hashtags: str
        :return: note's widget
        """
        print(self.notes_dict_list)

        memoLayout = QVBoxLayout()

        mainGroupBox = QGroupBox()
        mainGroupBox.setGeometry(QRect(300, 160, 261, 251))
        mainGroupBox.setMaximumSize(QSize(200, 200))

        mainGroupBox.setStyleSheet("border-radius: 10px;\n"
                                   "background-color: rgb(83,90,87);\n"
                                   "")

        mainLayout = QVBoxLayout(mainGroupBox)
        mainLayout.setContentsMargins(0, 0, 0, 0)
        topGroupBox = QGroupBox(mainGroupBox)
        topGroupBox.setStyleSheet("background-color: rgb(0, 0, 0);\n"
                                  "font: 87 9pt \"Arial Black\";\n"
                                  "color: white;")
        topGroupBox.setMaximumSize(QSize(200, 200))

        topLayout = QHBoxLayout(topGroupBox)
        labelName = QLabel(topGroupBox)
        labelName.setText(user_name)

        topLayout.addWidget(labelName)
        labelHashtag = QLabel(topGroupBox)
        hashtag = hashtags[len(hashtags) - 1]
        labelHashtag.setText(hashtag)

        topLayout.addWidget(labelHashtag)

        toolButton = QToolButton(popupMode=QToolButton.InstantPopup)
        toolButton.setText("...")
        toolButton.setCursor(QCursor(Qt.PointingHandCursor))
        toolButton.setCheckable(False)
        toolButton.setAutoRepeat(False)
        toolButton.setAutoExclusive(False)
        toolButton.setAutoRaise(False)

        toolMenu = QMenu(toolButton)
        toolButton.setMenu(toolMenu)

        self.active_note_menu(toolMenu, toolButton, index, memoLayout, hashtag, sys_name, user_name)

        topLayout.addWidget(toolButton)
        mainLayout.addWidget(topGroupBox)

        noteTextEdit = QTextEdit(mainGroupBox)
        noteTextEdit.setMaximumSize(QSize(200, 200))
        noteTextEdit.setStyleSheet(
            "background-color: rgb(230,216,203); border-style: outset; font:12pt 'sans-serif'; color: black;")

        noteTextEdit.setReadOnly(True)
        noteTextEdit.viewport().setCursor(Qt.ArrowCursor)
        noteText = self.open_text(index)
        noteTextEdit.setHtml(noteText)

        mainLayout.addWidget(noteTextEdit)

        memoLayout.addLayout(mainLayout)
        memoLayout.addWidget(mainGroupBox)
        self.noteLayout.addLayout(memoLayout)

        self.notes_dict_list[index]["note_layout"] = memoLayout
        self.notes_dict_list[index]["note_menu"] = toolMenu
        self.notes_dict_list[index]["note_tool_btn"] = toolButton
        self.notes_dict_list[index]["note_textedit"] = noteTextEdit
        self.notes_dict_list[index]["note_label_name"] = labelName
        self.notes_dict_list[index]["note_label_hashtag"] = labelHashtag

        print(self.notes_dict_list)

    def active_note_menu(self, menu, tool_btn, index, note_layout, hashtag, sys_name, user_name):
        """
        Clear and recreate context menu for note

        :param menu: QMenu
        :param tool_btn: QToolButton
        :param index: int
        :param note_layout: QLayout
        :param hashtag: str
        :param sys_name: str
        :param user_name: str
        :return: created note context menu
        """
        menu.clear()

        openAction = QWidgetAction(tool_btn)
        openAction.setText("Open")
        openAction.triggered.connect(lambda: self.change_open_note(sys_name=sys_name, index=index))
        menu.addAction(openAction)

        removeAction = QWidgetAction(tool_btn)
        removeAction.setText("Remove")
        removeAction.triggered.connect(
            lambda: self.note_del(index=index, note_layout=note_layout, note_hashtag=hashtag,
                                  sys_name=sys_name, user_name=user_name))
        menu.addAction(removeAction)

        renameAction = QWidgetAction(tool_btn)
        renameAction.setText("Rename")
        renameAction.triggered.connect(
            lambda: self.rename_note(sys_name, hashtag, index, user_name))
        menu.addAction(renameAction)

    @pyqtSlot(str)
    def show_note_text(self):
        """
        Create QTextDocument and activate text saving
        Add clip button in Heading
        :return: QTextDocument
        """
        note_doc = QTextDocument()
        highlighter = MyHighlighter(note_doc)
        note_doc.setHtml(self.open_text(self.open_note_index))
        self.mainTextEdit.setDocument(note_doc)
        self.mainTextEdit.setFocus()
        self.date_lbl.setText(self.notes_dict_list[self.open_note_index]["date"])
        self.note_name_lbl.setText(self.notes_dict_list[self.open_note_index]["user_name"])
        note_doc.contentsChanged.connect(lambda: self.save_note_text(note_doc.toHtml()))
        note_doc.contentsChanged.connect(lambda: self.save_note_hashtags(self.open_note_index))

        # Добавляем шрифты в clip
        addTitle = QAction('Add Title')
        addTitle.triggered.connect(lambda:self.add_title(note_doc))
        self.clipContextMenu.addAction(addTitle)
        self.clipButton.setMenu(self.clipContextMenu)

    def change_note_textedit(self, index):
        """
        Change note widget text
        :param index:int
        """
        noteText = self.open_text(index)
        self.notes_dict_list[index]["note_textedit"].setHtml(noteText)

    @pyqtSlot(str)
    def change_open_note(self, sys_name, index):
        """
        Change active note and widget layout
        :param sys_name: str
        :param index: int
        :return:
        """
        self.open_note_sys_name = str(sys_name)
        self.open_note_index = index

        if self.open_note_index == -1:
            self.show_main_note_text()
        else:
            self.clear_layout(self.widgetLay)
            self.show_note_text()
            self.create_all_img_button()
            self.create_all_audio_player()

        self.change_buttons()

    def change_buttons(self):

        if self.open_note_index == -1:
            self.widgetFrame.hide()
            self.noteFrame.show()
            self.clipButton.hide()
            self.plusButton.show()
            self.homeButton.hide()
        else:
            self.noteFrame.hide()
            self.widgetFrame.show()
            self.clipButton.show()
            self.plusButton.hide()
            self.homeButton.show()


    #todo-------------------------Fuctions for open and save text-------------------------
    @pyqtSlot(str)
    def save_note_text(self, text):
        """
        Saving and creating JSON File
        :param text: str
        :return: JSON File
        """
        note_sys_name = self.open_note_sys_name
        index = self.open_note_index
        self.notes_dict_list[index]["text"] = text
        self.notes_dict_list[index]["date"] = self.note_date_func()
        note_dict_copy = self.notes_dict_list[index].copy()

        del note_dict_copy["note_layout"]
        del note_dict_copy["note_menu"]
        del note_dict_copy["note_tool_btn"]
        del note_dict_copy["note_textedit"]
        del note_dict_copy["note_label_name"]
        del note_dict_copy["note_label_hashtag"]

        if "images_btn" in note_dict_copy.keys():
            del note_dict_copy["images_btn"]
        with open(self.path + "\\" + note_sys_name + ".json", 'w') as f:
            json.dump(note_dict_copy, f)
        self.change_note_textedit(index)

    def save_main_note_text(self):
        text = self.mainTextEdit.toPlainText()
        self.main_dict["text"] = text
        self.main_dict["date"] = self.note_date_func()

        with open(self.path + "\\" + "MainNote.json", 'w') as f:
            json.dump(self.main_dict, f)

    @pyqtSlot(str)
    def open_text(self, index):
        """
        For JSON Files opening
        :param index: int
        """
        if index != -1:
            return self.notes_dict_list[index]["text"]
        else:
            return self.main_dict["text"]

    def search_hashtags(self, html_text):
        """
        For searching hashtag in users text
        :param html_text: str
        :return: hashtag str
        """
        pattern = "@" + r"\w+" + "@"
        hashtags = findall(pattern, html_text)
        return hashtags

    def save_note_hashtags(self, index):
        hashtags = self.search_hashtags(self.notes_dict_list[index]["text"])
        self.notes_dict_list[index]["hashtags"] = ["@noname@"] + hashtags
        self.notes_dict_list[index]["date"] = self.note_date_func()
        note_dict_copy = self.notes_dict_list[index].copy()

        del note_dict_copy["note_layout"]
        del note_dict_copy["note_menu"]
        del note_dict_copy["note_tool_btn"]
        del note_dict_copy["note_textedit"]
        del note_dict_copy["note_label_name"]
        del note_dict_copy["note_label_hashtag"]

        if "images_btn" in note_dict_copy.keys():
            del note_dict_copy["images_btn"]
        with open(self.path + "\\" + self.notes_dict_list[index]["sys_name"] + ".json", 'w') as f:
            json.dump(note_dict_copy, f)
        self.notes_dict_list[index]["note_label_hashtag"].setText(
            self.notes_dict_list[index]["hashtags"][len(self.notes_dict_list[index]["hashtags"])-1]
        )
        if hashtags != []:
            self.active_note_menu(menu=self.notes_dict_list[index]["note_menu"],
                                  tool_btn=self.notes_dict_list[index]["note_tool_btn"],
                                  index=self.notes_dict_list[index]["index"],
                                  note_layout=self.notes_dict_list[index]["note_layout"],
                                  hashtag=self.notes_dict_list[index]["hashtags"][len(self.notes_dict_list[index]["hashtags"]) - 1],
                                  sys_name=self.notes_dict_list[index]["sys_name"],
                                  user_name=self.notes_dict_list[index]["user_name"])
            self.reactive_hash_dict()
            self.cycle_for_items()

    #todo-------------------------Fuctions for plusButton-------------------------
    def max_note_name_number(self):
        """
        :return: NoName max number
        """
        a = []
        for note in self.notes_dict_list:
            if note["user_name"][:6] == "NoName":
                a.append(int(note["user_name"][6:]))
        if a:
            return max(a)
        else:
            return 0

    def input_note_name(self, text):
        """
        :param text: str
        :return: Note Name str
        """
        name, ok = QInputDialog.getText(self, "Naming", "Enter name",
                                        text=text)
        note_user_name = None
        if ok and name != "":
            note_user_name = str(name)
        elif ok and name == "":
            note_user_name = "NoName" + str(self.max_note_name_number() + 1)
        else:
            return None
        return note_user_name

    @pyqtSlot()
    def new_note(self):  # СОЗДАНИЕ НОВОЙ КНОПКИ ЗАМЕТКИ
        """
        New Note Button Creating
        :return: Note Widget
        """
        new_note_user_name = self.input_note_name("NoName" + str(self.max_note_name_number() + 1))

        if new_note_user_name == None:
            return

        new_note_hashtag = "@noname@"

        if new_note_hashtag == None:
            return

        self.notes_count += 1
        index = self.notes_count - 1
        new_sys_name = "Note" + str(self.notes_count)

        # создание дизайна и добавление подзаметки
        memoLayout = QVBoxLayout()

        mainGroupBox = QGroupBox()
        mainGroupBox.setGeometry(QRect(300, 160, 261, 251))
        mainGroupBox.setMaximumSize(QSize(200, 200))

        mainGroupBox.setStyleSheet("border-radius: 10px;\n"
                                   "background-color: rgb(83,90,87);\n"
                                   "")

        mainLayout = QVBoxLayout(mainGroupBox)
        mainLayout.setContentsMargins(0, 0, 0, 0)
        topGroupBox = QGroupBox(mainGroupBox)
        topGroupBox.setStyleSheet("background-color: rgb(0, 0, 0);\n"
                                  "font: 87 9pt \"Arial Black\";\n"
                                  "color: white;")
        topGroupBox.setMaximumSize(QSize(200, 200))

        topLayout = QHBoxLayout(topGroupBox)
        labelName = QLabel(topGroupBox)
        labelName.setText(new_note_user_name)

        topLayout.addWidget(labelName)
        labelHashtag = QLabel(topGroupBox)
        labelHashtag.setText(new_note_hashtag)

        topLayout.addWidget(labelHashtag)

        toolButton = QToolButton(popupMode=QToolButton.InstantPopup)
        toolButton.setText("...")
        toolButton.setCursor(QCursor(Qt.PointingHandCursor))
        toolButton.setCheckable(False)
        toolButton.setAutoRepeat(False)
        toolButton.setAutoExclusive(False)
        toolButton.setAutoRaise(False)

        toolMenu = QMenu(toolButton)
        toolButton.setMenu(toolMenu)

        self.active_note_menu(toolMenu, toolButton, index, memoLayout, new_note_hashtag, new_sys_name, new_note_user_name)

        topLayout.addWidget(toolButton)
        mainLayout.addWidget(topGroupBox)

        noteTextEdit = QTextEdit(mainGroupBox)
        noteTextEdit.setMinimumSize(QSize(70, 120))
        noteTextEdit.setMaximumSize(QSize(200, 200))
        noteTextEdit.setStyleSheet(
            "background-color: rgb(230,216,203); border-style: outset; font:12pt 'sans-serif'; color: black;")

        noteTextEdit.setReadOnly(True)
        noteTextEdit.viewport().setCursor(Qt.ArrowCursor)
        noteText = ""
        noteTextEdit.setText(noteText[:24])
        mainLayout.addWidget(noteTextEdit)

        memoLayout.addLayout(mainLayout)
        memoLayout.addWidget(mainGroupBox)
        self.noteLayout.addLayout(memoLayout)

        # Creating note in Left Menu
        if not new_note_hashtag in self.hash_dict:
            new_root_item = QTreeWidgetItem()
            new_root_item.setText(0, new_note_hashtag)
            new_item = QTreeWidgetItem()
            new_item.setText(0, new_note_user_name)
            new_root_item.addChild(new_item)
            self.tree.addTopLevelItem(new_root_item)
            self.tree.itemDoubleClicked.connect(self.double_click_on_item)
            self.hash_dict[new_note_hashtag] = []
            self.hash_dict[new_note_hashtag].append({"user_name": new_note_user_name, "note_item": new_item})
        else:
            self.hash_dict["{}".format(new_note_hashtag)].append({"user_name": new_note_user_name, "note_item": ""})
            self.tree.clear()
            self.cycle_for_items()

        # Add new note dict in list
        new_note_dict = {"user_name": new_note_user_name,
                         "sys_name": new_sys_name,
                         "text": "",
                         "index": index,
                         "date": self.note_date_func(),
                         "hashtags": [new_note_hashtag],
                         "note_layout": memoLayout,
                         "note_menu": toolMenu,
                         "note_tool_btn": toolButton,
                         "note_textedit": noteTextEdit,
                         "note_label_name": labelName,
                         "note_label_hashtag": labelHashtag}

        self.notes_dict_list.append(new_note_dict)


        # save dict in JSON File
        text = '{{"user_name": "{}", "sys_name": "{}", "text": "", "index": {}, "date": "{}", "hashtags": ["{}"]}}'.format(
            new_note_user_name, new_sys_name, index, self.note_date_func(), new_note_hashtag)

        with open(self.path + r'\{}'.format(new_sys_name) + '.json', 'w+') as f:
            f.write(text)

        # open and activate note
        self.change_open_note(new_sys_name, index)


    #todo-------------------------Functions for context menu-------------------------

    @pyqtSlot(str, "QPushButton", int)
    def rename_note(self, sys_name, note_hashtag, index, user_name): # ПЕРЕИМЕНОВАНИЕ ЗАМЕТКИ
        """
        Note Rename
        :param sys_name: str
        :param note_hashtag: str
        :param index: int
        :param user_name: str
        :return:
        """
        # user can input new note name
        new_user_name = self.input_note_name(text = user_name)
        if new_user_name == None:
            return

        # Rename note in left menu
        for i in range(len(self.hash_dict[note_hashtag])):
            if self.hash_dict[note_hashtag][i]["user_name"] == self.notes_dict_list[index]["user_name"]:
                self.hash_dict[note_hashtag][i]["user_name"] = new_user_name
        self.tree.clear()
        self.cycle_for_items()

        self.notes_dict_list[index]["note_label_name"].setText(new_user_name)
        # change name in dict
        self.notes_dict_list[index]["user_name"] = new_user_name
        note_dict_copy = self.notes_dict_list[index].copy()
        del note_dict_copy["note_layout"]
        del note_dict_copy["note_menu"]
        del note_dict_copy["note_tool_btn"]
        del note_dict_copy["note_textedit"]
        del note_dict_copy["note_label_name"]
        del note_dict_copy["note_label_hashtag"]
        if "images_btn" in note_dict_copy.keys():
            del note_dict_copy["images_btn"]
        # cange File name
        with open(self.path + "\\" + sys_name + ".json", 'w') as f:
            json.dump(note_dict_copy, f)

        self.notes_dict_list[index]["date"] = self.note_date_func()  # put changing time

    @pyqtSlot("QPushButton", int, str)
    def note_del(self, note_layout, index, note_hashtag, sys_name, user_name): # УДАЛЯЕТ ПОДЗАМЕТКУ
        """
        Function for note widget deleting
        :param note_layout: QLayout
        :param index: int
        :param note_hashtag: str
        :param sys_name: str
        :param user_name:str
        """
        from shutil import move

        # Delete from Left Menu
        for note in self.hash_dict[note_hashtag]:
            if note["user_name"] == self.notes_dict_list[index]["user_name"]:
                self.hash_dict[note_hashtag].remove(note)

        self.notes_dict_list.pop(index)  # delete from list
        self.notes_count = self.notes_count - 1

        if self.hash_dict[note_hashtag] == []:
            del self.hash_dict[note_hashtag]

        self.tree.clear() # delete from menu
        self.cycle_for_items() # put notes in menu again

        # File and widget deleting
        self.clear_layout(note_layout)
        note_layout.deleteLater()

        os.remove(self.path + r"\{}".format(sys_name) + ".json")

        # Open Main Note
        self.change_open_note("MainNote", -1)

        # Rename JSON Files
        i = index + 2
        while os.path.exists(self.path + r"\Note" + str(i) + ".json"):
            move(self.path + r"\Note" + str(i) + ".json", self.path + r"\Note" + str(i - 1) + ".json")
            i += 1

        # Rename Notes in list
        for note_dict in self.notes_dict_list[index:]:
            note_dict["index"] = note_dict["index"] - 1
            note_dict["sys_name"] = note_dict["sys_name"][:4] + str(note_dict["index"]+ 1)
            note_dict_copy = note_dict.copy()

            del note_dict_copy["note_layout"]
            del note_dict_copy["note_menu"]
            del note_dict_copy["note_tool_btn"]
            del note_dict_copy["note_textedit"]
            del note_dict_copy["note_label_name"]
            del note_dict_copy["note_label_hashtag"]

            if "images_btn" in note_dict_copy.keys():
                del note_dict_copy["images_btn"]
            with open(self.path + r"\{}".format(sys_name) + ".json", 'w+') as f:
                json.dump(note_dict_copy, f)

        self.after_delete_cycle_for_notes(index)

    def clear_layout(self, layout):
        """
        :param layout: QLayout
        """

        if layout != None:
            while layout.count():
                item = layout.takeAt(0)
                if item.widget() != None:
                    item.widget().setParent(None)
                elif item.layout() != None:
                    self.clear_layout(item.layout())
                    return

    def after_delete_cycle_for_notes(self, index):
        """Проходится циклом по всем заметкам начиная с индекса удаленной заметки и
        заново запускает каждое меню заметки. Это нужно для того, чтобы не было херни с индексами и последующим
        удалением заметок"""
        for note in self.notes_dict_list[index:]:
            self.active_note_menu(menu = note["note_menu"],
                                  tool_btn = note["note_tool_btn"],
                                  index = note["index"],
                                  note_layout = note["note_layout"],
                                  hashtag = note["hashtags"][len(note["hashtags"])-1],
                                  sys_name = note["sys_name"],
                                  user_name = note["user_name"])

    #todo-------------------------Functions for tree menu-------------------------
    def cycle_for_items(self): # ЗАНОВО СОЗДАЕТ ЗАМЕТКИ В ЛЕВОМ МЕНЮ ПО КАТЕГОРИЯМ
        self.tree.clear()
        items_lst = []
        for key in self.hash_dict:
            root_item = QTreeWidgetItem()
            root_item.setText(0, key)
            for i in self.hash_dict[key]:
                item = QTreeWidgetItem()
                item.setText(0, i["user_name"])
                root_item.addChild(item)
                i["note_item"] = item
            items_lst.append(root_item)
        self.tree.addTopLevelItems(items_lst)
        self.tree.itemDoubleClicked.connect(self.double_click_on_item)

    def reactive_hash_dict(self):
        self.hash_dict = {}
        for note in self.notes_dict_list:
            self.hash_dict.update({note["hashtags"][len(note["hashtags"]) - 1]: []})
        for note in self.notes_dict_list:
            for key in self.hash_dict:
                if note["hashtags"][len(note["hashtags"]) - 1] == key:
                    self.hash_dict[key].append({"user_name": note["user_name"], "note_item": ""})

    def double_click_on_item(self, item): # Open note with double click left menu
        name = item.text(0)
        for note in self.notes_dict_list:
            if note["user_name"] == str(name) :
                self.change_open_note(note["sys_name"], note["index"])

    def tree_context_menu(self, position): # СОЗДАЕТ КОНТЕКСТНОЕ МЕНЮ ДЛЯ ЛЕВОГО МЕНЮ
        item = self.tree.itemAt(position)
        if item != None:
            for hashtag in self.hash_dict:
                for note in self.hash_dict[hashtag]:
                    if note["note_item"] == item:
                        user_name = note["user_name"]
                        i = 0
                        while user_name != self.notes_dict_list[i]["user_name"]:
                            i += 1
                        print(self.notes_dict_list[i]["index"])
                        index = self.notes_dict_list[i]["index"]
                        note_layout = self.notes_dict_list[i]["note_layout"]
                        note_hashtag = self.notes_dict_list[i]["hashtags"][len(self.notes_dict_list[i]["hashtags"])-1]
                        sys_name = self.notes_dict_list[i]["sys_name"]

            self.tree_menu = QMenu()

            removeAct = QAction('Delete', self)
            removeAct.triggered.connect(
                lambda: self.note_del(index=index, note_layout=note_layout, note_hashtag=note_hashtag, sys_name=sys_name,
                                      user_name=user_name))
            renameAct = QAction('Rename', self)
            renameAct.triggered.connect(lambda: self.rename_note(sys_name, note_layout, note_hashtag, index, user_name))

            self.tree_menu.addAction(removeAct)
            self.tree_menu.addAction(renameAct)
            self.tree_menu.addSeparator()  # вообще не знаю че это даже не смотри

            self.tree_menu.exec_(self.tree.viewport().mapToGlobal(position))

    @pyqtSlot()
    def show_tree_context_menu(self):  # Represent context menu
        self.tree_menu.exec_(QCursor.pos())

    def show_left_menu(self):

        if self.frame_menu.isVisible() == True:
            self.frame_menu.setVisible(False)
            self.frame_menu.move(self.x() + 38, self.y() + 71)
        else:
            self.frame_menu.setVisible(True)
            self.frame_menu.move(self.x() + 38, self.y() + 71)


    #todo-------------------------Functions for image-------------------------

    def check_for_added_image(self, img_name):
        if ("images" in self.notes_dict_list[self.open_note_index].keys()) and (img_name in self.notes_dict_list[self.open_note_index]["images"]):
                errorMessage = QMessageBox()
                errorMessage.setIcon(QMessageBox.Critical)
                errorMessage.setText("This image has already been added to the {}.".format(self.notes_dict_list[self.open_note_index]["user_name"]))
                errorMessage.setWindowTitle("Error")
                return errorMessage
        else:
            return None

    @pyqtSlot(str)
    def add_img(self):  # ДОБАВЛЯЕТ КАРТИНКУ В АКТИВНУЮ ЗАМЕТКУ
        fileName, _ = QFileDialog.getOpenFileName(None, "Select Image", "",
                                                  "Image Files (*.png *.jpg *jpeg *.bmp)")
        if not fileName:
            return None
        errorMessage = self.check_for_added_image(fileName)
        if errorMessage:
            errorMessage.exec_()
            return
        img_button = MyPushButton("")
        img_button.leftClick.connect(lambda: self.openImage(fileName))
        img_button.setGeometry(QRect(100, 100, 100, 100))
        img_button.setIcon(QIcon(fileName))
        img_button.setIconSize(QSize(img_button.width(), img_button.height()))
        img_button.rightClick.connect(lambda: self.img_context_menu(img_button, self.open_note_index, fileName))

        self.widgetLay.addWidget(img_button)

        if not "images" in self.notes_dict_list[self.open_note_index].keys():
            self.notes_dict_list[self.open_note_index]["images"] = []
        self.notes_dict_list[self.open_note_index]["images"].append(fileName)
        if not "images_btn" in self.notes_dict_list[self.open_note_index].keys():
            self.notes_dict_list[self.open_note_index]["images_btn"] = []
        self.notes_dict_list[self.open_note_index]["images_btn"].append(img_button)
        note_dict_copy = self.notes_dict_list[self.open_note_index].copy()
        del note_dict_copy["note_layout"]
        del note_dict_copy["note_menu"]
        del note_dict_copy["note_tool_btn"]
        del note_dict_copy["note_textedit"]
        del note_dict_copy["note_label_name"]
        del note_dict_copy["note_label_hashtag"]
        if "images_btn" in note_dict_copy.keys():
            del note_dict_copy["images_btn"]
        with open(self.path + "\\" + self.open_note_sys_name + ".json", "w") as f:
            json.dump(note_dict_copy, f)

    def img_context_menu(self, img_button, index, img_path): # СОЗДАЕТ КОНТЕКСТНОЕ МЕНЮ
        img_menu = QMenu()

        removeAct = QAction('Delete')
        removeAct.triggered.connect(lambda: self.image_delete(index, img_button, img_path))
        img_menu.addAction(removeAct)

        img_button.customContextMenuRequested.connect(lambda: self.show_context_menu(img_menu))

    @pyqtSlot()
    def show_context_menu(self, menu): # ОТОБРАЖАЕТ КОНТЕКСТНОЕ МЕНЮ
        # Показываем меню и выбираем ему место
        menu.exec_(QCursor.pos())

    def image_delete(self, index, img_button, img_path):
        i = 0
        while img_path != self.notes_dict_list[index]["images"][i]:
            i += 1
        del self.notes_dict_list[index]["images"][i]
        img_button.setParent(None)
        img_button.deleteLater()

    def openImage(self, fileName_):
        from ctypes import windll
        print(fileName_)
        self.openImgFrame = QFrame()
        self.openImgFrame.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)
        screenSize1 = windll.user32.GetSystemMetrics(0)
        screenSize2 = windll.user32.GetSystemMetrics(1)
        self.openImgFrame.setFixedSize(0.8 * screenSize1, 0.8 * screenSize2)
        imgLay = QHBoxLayout()
        img_button = QPushButton()
        img_button.clicked.connect(self.openImgFrame.hide)
        # img_button.setGeometry(QRect(100, 100, 0.8*screenSize1, 0.8*screenSize2))
        img_button.setIcon(QIcon(fileName_))
        img_button.setIconSize(QSize(0.8 * screenSize1, 0.8 * screenSize2))
        # img_button.setIconSize(QSize(img_button.width(), img_button.height()))
        self.openImgFrame.setLayout(imgLay)
        imgLay.addWidget(img_button)
        self.openImgFrame.show()
        # if self.openImgFrame.isVisible():
        #     self.openImgFrame.setVisible(False)
        # else:
        #     self.openImgFrame.setVisible(True)

    def create_all_img_button(self):
        if (self.open_note_index != -1) and ("images" in self.notes_dict_list[self.open_note_index].keys()):
            for img in self.notes_dict_list[self.open_note_index]["images"]:
                img_button = MyPushButton("")
                img_button.setGeometry(QRect(100, 100, 100, 100))
                img_button.setIcon(QIcon(img))
                img_button.setIconSize(QSize(img_button.width(), img_button.height()))
                img_button.clicked.connect(lambda: self.openImage(img))
                img_button.rightClick.connect(lambda: self.img_context_menu(img_button, self.open_note_index, img))
                self.widgetLay.addWidget(img_button)


    #todo-------------------------Functions for audio-------------------------

    def check_for_added_audio(self, audio_path):
        if ("audio" in self.notes_dict_list[self.open_note_index].keys()):
            for audio_dict in self.notes_dict_list[self.open_note_index]["audio"]:
                if audio_path == audio_dict["audio_path"]:
                    errorMessage = QMessageBox()
                    errorMessage.setIcon(QMessageBox.Critical)
                    errorMessage.setText("This audio has already been added to the {}.".format(self.notes_dict_list[self.open_note_index]["user_name"]))
                    errorMessage.setWindowTitle("Error")
                    return errorMessage
        else:
            return None

    def create_all_audio_player(self):
        if (self.open_note_index != -1) and ("audio" in self.notes_dict_list[self.open_note_index].keys()):
            for audio_dict in self.notes_dict_list[self.open_note_index]["audio"]:
                url = QUrl(audio_dict["audio_path"])
                playWidget = AudioPlayer(audio_dict["audio_name"], url)
                self.widgetLay.addWidget(playWidget)

    def add_audio(self):
        file = QFileDialog.getOpenFileName(parent=self,
                                           caption="Выберите файл")

        if not file[0]:
            return None
        errorMessage = self.check_for_added_audio(file[0])
        if errorMessage:
            errorMessage.exec_()
            return

        url = QUrl(file[0])
        last_slash_index = file[0].rfind("/")
        audio_name = file[0][last_slash_index+1:]
        if file[0] != '':
            if "audio" not in self.notes_dict_list[self.open_note_index].keys():
                self.notes_dict_list[self.open_note_index]["audio"] = []
            self.notes_dict_list[self.open_note_index]["audio"].append({"audio_name": audio_name, "audio_path": file[0]})
            self.notes_dict_list[self.open_note_index]["date"] = self.note_date_func()
            note_dict_copy = self.notes_dict_list[self.open_note_index].copy()
            del note_dict_copy["note_layout"]
            del note_dict_copy["note_menu"]
            del note_dict_copy["note_tool_btn"]
            del note_dict_copy["note_textedit"]
            del note_dict_copy["note_label_name"]
            del note_dict_copy["note_label_hashtag"]
            if "images_btn" in note_dict_copy.keys():
                del note_dict_copy["images_btn"]
            with open(self.path + "\\" + self.open_note_sys_name + ".json", 'w') as f:
                json.dump(note_dict_copy, f)
            playWidget = AudioPlayer(audio_name, url)
            self.widgetLay.addWidget(playWidget)


    #todo-------------------------Other functions-------------------------

    def note_date_func(self): # ВОЗВРАЩАЕТ ТЕКУЩЕЕ ВРЕМЯ В ВИДЕ СТРОКИ
        import datetime
        time_now = str(datetime.datetime.now())[:19]
        # year = time_now[:4]
        # month = time_now[4:7]
        # day = time_now[7:10]
        # hours = time_now[11:13]
        # minutes = time_now[13:16]
        # seconds = time_now[16:19]
        return time_now

    def on_click(self):
        pass

    def add_title(self, textW):
        #textW.acceptRichText(True)
        text = textW.toPlainText()
        print(textW.toHtml())

    def closeEvent(self, event):
        self.frame_menu.hide()
        event.accept()

    # def save_all_json(self): # ТЕСТОВАЯ ФУНКЦИЯ СОХРАНЕНИЯ JSON ПРИ ЗАКРЫТИИ ПРИЛОЖЕНИЯ
    #     for dict in self.notes_dict_list:
    #         with open(self.path + "\\" + "Note" + str(dict["number"]) + ".json", 'w') as f:
    #             json.dump(dict, f)
    #     with open(self.path + "\\" + "MainNote" + ".json", 'w') as f:
    #         json.dump(self.main_dict, f)
    #
    # def closeEvent(self, event):
    #     self.save_all_json()

def setup_thread_excepthook(): # ФУНКЦИЯ ДЛЯ ОБРАБОТКИ ВСЕХ ИСКЛЮЧЕНИЙ
    from threading import Thread
    init_original = Thread.__init__

    def init(self, *args, **kwargs):

        init_original(self, *args, **kwargs)
        run_original = self.run

        def run_with_except_hook(*args2, **kwargs2):
            try:
                run_original(*args2, **kwargs2)
            except Exception:
                sys.excepthook(*sys.exc_info())

        self.run = run_with_except_hook

    Thread.__init__ = init

if __name__ == '__main__':
    sys.excepthook = setup_thread_excepthook()
    app = QApplication(sys.argv)
    app.processEvents()

    # DESIGN
    app.setStyle("Fusion")
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ToolTipBase, Qt.white)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)

    demo = Notes()
    demo.show()
    sys.exit(app.exec_())
